<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhuanjier.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="转接的博客">
<meta property="og:url" content="https://zhuanjier.github.io/blog/page/7/index.html">
<meta property="og:site_name" content="转接的博客">
<meta property="og:locale">
<meta property="article:author" content="转接">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhuanjier.github.io/blog/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>转接的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">转接的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/25/backpackproblem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/25/backpackproblem/" class="post-title-link" itemprop="url">背包问题BackpackProblem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-25 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-25T06:11:00+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void package(int *weight,int *size,int n,int c);//构造最优矩阵</span><br><span class="line">void getResult(int n,int c,int *res,int *size,int *weight);//构造最优解</span><br><span class="line">int f[10][100];</span><br><span class="line">//构造最优矩阵</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">vector&lt;int&gt; vweight;//定义一个vector数组vweight</span><br><span class="line">vector&lt;int&gt; vsize;</span><br><span class="line">int number;</span><br><span class="line">vweight.push_back(0);</span><br><span class="line">vsize.push_back(0);</span><br><span class="line">cout &lt;&lt; &quot;请输入每个物品的重量：&quot;; </span><br><span class="line">while (1)&#123;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">vweight.push_back(number);//每输入一个数字就把它添加到数组的最后</span><br><span class="line">if (cin.get() == &#x27;\n&#x27;)//如果是回车符则跳出循环</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">int *weight = new int[vweight.size()];//每个物品的重量</span><br><span class="line">    if (!vweight.empty())&#123;</span><br><span class="line">        memcpy(weight, &amp;vweight[0], vweight.size()*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line">cout &lt;&lt; &quot;请输入每个物品的价值：&quot;; </span><br><span class="line">while (1) &#123;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">vsize.push_back(number);</span><br><span class="line">if (cin.get() == &#x27;\n&#x27;)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">    int *size = new int[vsize.size()];//每个物品的价值</span><br><span class="line">    if (!vsize.empty())&#123;</span><br><span class="line">        memcpy(size, &amp;vsize[0], vsize.size()*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line">    if(vweight.size()!=vsize.size())&#123;</span><br><span class="line">    cout &lt;&lt; &quot;数据输入错误，请重新开始&quot;; </span><br><span class="line">    exit(0);</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; &quot;请输入背包的总容量：&quot;;</span><br><span class="line">int c; //背包能容的重量</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line">int n = vweight.size()-1; //物品的个数</span><br><span class="line">int res[n];</span><br><span class="line">for(int a=0;a&lt;n;a++)&#123;</span><br><span class="line">res[a]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i,j;</span><br><span class="line">package(weight,size,n,c);</span><br><span class="line">for(i=0;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=0;j&lt;=c;j++)</span><br><span class="line">printf(&quot;%2d &quot;,f[i][j]);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">getResult(n,c,res,size,weight);</span><br><span class="line">cout &lt;&lt; &quot;放入背包最大价值: &quot; &lt;&lt; f[n][c] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;放入背包的物品为: &quot;;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">if(res[i] == 1)</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void package(int *weight,int *size,int n,int c)&#123;</span><br><span class="line">int i,j;</span><br><span class="line">//初始化矩阵</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">f[i][0] = 0;</span><br><span class="line">for(j=1;j&lt;=c;j++)</span><br><span class="line">f[0][j] = 0;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=c;j++)&#123;</span><br><span class="line">//当容量够放入第i个物品，并且放入之后的价值要比不放大</span><br><span class="line">if(weight[i] &lt;= j &amp;&amp; f[i-1][j-weight[i]] + size[i] &gt; f[i-1][j])&#123;</span><br><span class="line">f[i][j] = f[i-1][j-weight[i]] + size[i];</span><br><span class="line">&#125;else</span><br><span class="line">f[i][j] = f[i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getResult(int n,int c,int *res,int *size,int *weight)&#123;</span><br><span class="line">//构造最优解</span><br><span class="line">int i,j;</span><br><span class="line">j = c;</span><br><span class="line">for(i=n;i&gt;=1;i--)&#123;</span><br><span class="line">if(f[i][j] != f[i-1][j])&#123;</span><br><span class="line">res[i] = 1;</span><br><span class="line">j = j - weight[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。即自顶向下的备忘录法或自底向上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/25/huffman/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/25/huffman/" class="post-title-link" itemprop="url">霍夫曼编码Huffman</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-25 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-25T06:11:00+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">// 统计字符频度的临时结点</span><br><span class="line">typedef struct &#123;</span><br><span class="line">unsigned char uch;// 以8bits为单元的无符号字符</span><br><span class="line">unsigned long weight;// 每类（以二进制编码区分）字符出现频度</span><br><span class="line">&#125; TmpNode;</span><br><span class="line">// 哈夫曼树结点</span><br><span class="line">typedef struct &#123;</span><br><span class="line">unsigned char uch;// 以8bits为单元的无符号字符</span><br><span class="line">unsigned long weight;// 每类（以二进制编码区分）字符出现频度</span><br><span class="line">char *code;// 字符对应的哈夫曼编码（动态分配存储空间）</span><br><span class="line">int parent, lchild, rchild;// 定义双亲和左右孩子</span><br><span class="line">&#125; HufNode, *HufTree;</span><br><span class="line">// 选择最小和次小的两个结点，建立哈夫曼树调用</span><br><span class="line">void select(HufNode *huf_tree, unsigned int n, int *s1, int *s2)</span><br><span class="line">&#123;</span><br><span class="line">// 找最小</span><br><span class="line">unsigned int i;</span><br><span class="line">unsigned long min = ULONG_MAX;</span><br><span class="line">for(i = 0; i &lt; n; ++i)           </span><br><span class="line">if(huf_tree[i].parent == 0 &amp;&amp; huf_tree[i].weight &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = huf_tree[i].weight;</span><br><span class="line">*s1 = i;</span><br><span class="line">&#125;</span><br><span class="line">huf_tree[*s1].parent=1;   // 标记此结点已被选中</span><br><span class="line">// 找次小</span><br><span class="line">min=ULONG_MAX;</span><br><span class="line">for(i = 0; i &lt; n; ++i)            </span><br><span class="line">if(huf_tree[i].parent == 0 &amp;&amp; huf_tree[i].weight &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">min = huf_tree[i].weight;</span><br><span class="line">*s2 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">// 建立哈夫曼树</span><br><span class="line">void CreateTree(HufNode *huf_tree, unsigned int char_kinds, unsigned int node_num)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i;</span><br><span class="line">int s1, s2;</span><br><span class="line">for(i = char_kinds; i &lt; node_num; ++i)  </span><br><span class="line">&#123; </span><br><span class="line">select(huf_tree, i, &amp;s1, &amp;s2);// 选择最小的两个结点</span><br><span class="line">huf_tree[s1].parent = huf_tree[s2].parent = i; </span><br><span class="line">huf_tree[i].lchild = s1; </span><br><span class="line">huf_tree[i].rchild = s2; </span><br><span class="line">huf_tree[i].weight = huf_tree[s1].weight + huf_tree[s2].weight; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">// 生成哈夫曼编码</span><br><span class="line">void HufCode(HufNode *huf_tree, unsigned char_kinds)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i;</span><br><span class="line">int cur, next, index;</span><br><span class="line">char *code_tmp = (char *)malloc(256*sizeof(char));// 暂存编码，最多256个叶子，编码长度不超多255</span><br><span class="line">code_tmp[256-1] = &#x27;\0&#x27;; </span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i) </span><br><span class="line">&#123;</span><br><span class="line">index = 256-1;// 编码临时空间索引初始化</span><br><span class="line">// 从叶子向根反向遍历求编码</span><br><span class="line">for(cur = i, next = huf_tree[i].parent; next != 0; </span><br><span class="line">cur = next, next = huf_tree[next].parent)  </span><br><span class="line">if(huf_tree[next].lchild == cur) </span><br><span class="line">code_tmp[--index] = &#x27;0&#x27;;// 左&#x27;0&#x27;</span><br><span class="line">else </span><br><span class="line">code_tmp[--index] = &#x27;1&#x27;;// 右&#x27;1&#x27;</span><br><span class="line">huf_tree[i].code = (char *)malloc((256-index)*sizeof(char));// 为第i个字符编码动态分配存储空间 </span><br><span class="line">strcpy(huf_tree[i].code, &amp;code_tmp[index]);     // 正向保存编码到树结点相应域中</span><br><span class="line">&#125; </span><br><span class="line">free(code_tmp);// 释放编码临时空间</span><br><span class="line">&#125;</span><br><span class="line">// 压缩函数</span><br><span class="line">int compress(char *ifname, char *ofname)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i, j;</span><br><span class="line">unsigned int char_kinds;// 字符种类</span><br><span class="line">unsigned char char_temp;// 暂存8bits字符</span><br><span class="line">unsigned long file_len = 0;</span><br><span class="line">FILE *infile, *outfile;</span><br><span class="line">TmpNode node_temp;</span><br><span class="line">unsigned int node_num;</span><br><span class="line">HufTree huf_tree;</span><br><span class="line">char code_buf[256] = &quot;\0&quot;;// 待存编码缓冲区</span><br><span class="line">unsigned int code_len;</span><br><span class="line">/*</span><br><span class="line">** 动态分配256个结点，暂存字符频度，</span><br><span class="line">** 统计并拷贝到树结点后立即释放</span><br><span class="line">*/</span><br><span class="line">TmpNode *tmp_nodes =(TmpNode *)malloc(256*sizeof(TmpNode));</span><br><span class="line">// 初始化暂存结点</span><br><span class="line">for(i = 0; i &lt; 256; ++i)</span><br><span class="line">&#123;</span><br><span class="line">tmp_nodes[i].weight = 0;</span><br><span class="line">tmp_nodes[i].uch = (unsigned char)i;// 数组的256个下标与256种字符对应</span><br><span class="line">&#125;</span><br><span class="line">// 遍历文件，获取字符频度</span><br><span class="line">infile = fopen(ifname, &quot;rb&quot;);</span><br><span class="line">// 判断输入文件是否存在</span><br><span class="line">if (infile == NULL)</span><br><span class="line">return -1;</span><br><span class="line">fread((char *)&amp;char_temp, sizeof(unsigned char), 1, infile);// 读入一个字符</span><br><span class="line">while(!feof(infile))</span><br><span class="line">&#123;</span><br><span class="line">++tmp_nodes[char_temp].weight;// 统计下标对应字符的权重，利用数组的随机访问快速统计字符频度</span><br><span class="line">++file_len;</span><br><span class="line">fread((char *)&amp;char_temp, sizeof(unsigned char), 1, infile);// 读入一个字符</span><br><span class="line">&#125;</span><br><span class="line">fclose(infile);</span><br><span class="line">// 排序，将频度为零的放最后，剔除</span><br><span class="line">for(i = 0; i &lt; 256-1; ++i)           </span><br><span class="line">for(j = i+1; j &lt; 256; ++j)</span><br><span class="line">if(tmp_nodes[i].weight &lt; tmp_nodes[j].weight)</span><br><span class="line">&#123;</span><br><span class="line">node_temp = tmp_nodes[i];</span><br><span class="line">tmp_nodes[i] = tmp_nodes[j];</span><br><span class="line">tmp_nodes[j] = node_temp;</span><br><span class="line">&#125;</span><br><span class="line">// 统计实际的字符种类（出现次数不为0）</span><br><span class="line">for(i = 0; i &lt; 256; ++i)</span><br><span class="line">if(tmp_nodes[i].weight == 0) </span><br><span class="line">break;</span><br><span class="line">char_kinds = i;</span><br><span class="line">if (char_kinds == 1)</span><br><span class="line">&#123;</span><br><span class="line">outfile = fopen(ofname, &quot;wb&quot;);// 打开压缩后将生成的文件</span><br><span class="line">fwrite((char *)&amp;char_kinds, sizeof(unsigned int), 1, outfile);// 写入字符种类</span><br><span class="line">fwrite((char *)&amp;tmp_nodes[0].uch, sizeof(unsigned char), 1, outfile);// 写入唯一的字符</span><br><span class="line">fwrite((char *)&amp;tmp_nodes[0].weight, sizeof(unsigned long), 1, outfile);// 写入字符频度，也就是文件长度</span><br><span class="line">free(tmp_nodes);</span><br><span class="line">fclose(outfile);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">node_num = 2 * char_kinds - 1;// 根据字符种类数，计算建立哈夫曼树所需结点数 </span><br><span class="line">huf_tree = (HufNode *)malloc(node_num*sizeof(HufNode));// 动态建立哈夫曼树所需结点     </span><br><span class="line">// 初始化前char_kinds个结点</span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i) </span><br><span class="line">&#123; </span><br><span class="line">// 将暂存结点的字符和频度拷贝到树结点</span><br><span class="line">huf_tree[i].uch = tmp_nodes[i].uch; </span><br><span class="line">huf_tree[i].weight = tmp_nodes[i].weight;</span><br><span class="line">huf_tree[i].parent = 0; </span><br><span class="line">&#125;</span><br><span class="line">free(tmp_nodes); // 释放字符频度统计的暂存区</span><br><span class="line">// 初始化后node_num-char_kins个结点</span><br><span class="line">for(; i &lt; node_num; ++i) </span><br><span class="line">huf_tree[i].parent = 0; </span><br><span class="line">CreateTree(huf_tree, char_kinds, node_num);// 创建哈夫曼树</span><br><span class="line">HufCode(huf_tree, char_kinds);// 生成哈夫曼编码</span><br><span class="line">// 写入字符和相应权重，供解压时重建哈夫曼树</span><br><span class="line">outfile = fopen(ofname, &quot;wb&quot;);// 打开压缩后将生成的文件</span><br><span class="line">fwrite((char *)&amp;char_kinds, sizeof(unsigned int), 1, outfile);// 写入字符种类</span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fwrite((char *)&amp;huf_tree[i].uch, sizeof(unsigned char), 1, outfile);// 写入字符（已排序，读出后顺序不变）</span><br><span class="line">fwrite((char *)&amp;huf_tree[i].weight, sizeof(unsigned long), 1, outfile);// 写入字符对应权重</span><br><span class="line">&#125;</span><br><span class="line">// 紧接着字符和权重信息后面写入文件长度和字符编码</span><br><span class="line">fwrite((char *)&amp;file_len, sizeof(unsigned long), 1, outfile);// 写入文件长度</span><br><span class="line">infile = fopen(ifname, &quot;rb&quot;);// 以二进制形式打开待压缩的文件</span><br><span class="line">fread((char *)&amp;char_temp, sizeof(unsigned char), 1, infile);     // 每次读取8bits</span><br><span class="line">while(!feof(infile))</span><br><span class="line">&#123;</span><br><span class="line">// 匹配字符对应编码</span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i)</span><br><span class="line">if(char_temp == huf_tree[i].uch)</span><br><span class="line">strcat(code_buf, huf_tree[i].code);</span><br><span class="line">// 以8位（一个字节长度）为处理单元</span><br><span class="line">while(strlen(code_buf) &gt;= 8)</span><br><span class="line">&#123;</span><br><span class="line">char_temp = &#x27;\0&#x27;;// 清空字符暂存空间，改为暂存字符对应编码</span><br><span class="line">for(i = 0; i &lt; 8; ++i)</span><br><span class="line">&#123;</span><br><span class="line">char_temp &lt;&lt;= 1;// 左移一位，为下一个bit腾出位置</span><br><span class="line">if(code_buf[i] == &#x27;1&#x27;)</span><br><span class="line">char_temp = 1;// 当编码为&quot;1&quot;，通过或操作符将其添加到字节的最低位</span><br><span class="line">&#125;</span><br><span class="line">fwrite((char *)&amp;char_temp, sizeof(unsigned char), 1, outfile);// 将字节对应编码存入文件</span><br><span class="line">strcpy(code_buf, code_buf+8);// 编码缓存去除已处理的前八位</span><br><span class="line">&#125;</span><br><span class="line">fread((char *)&amp;char_temp, sizeof(unsigned char), 1, infile);     // 每次读取8bits</span><br><span class="line">&#125;</span><br><span class="line">// 处理最后不足8bits编码</span><br><span class="line">code_len = strlen(code_buf);</span><br><span class="line">if(code_len &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">char_temp = &#x27;\0&#x27;;</span><br><span class="line">for(i = 0; i &lt; code_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">char_temp &lt;&lt;= 1;</span><br><span class="line">if(code_buf[i] == &#x27;1&#x27;)</span><br><span class="line">char_temp = 1;</span><br><span class="line">&#125;</span><br><span class="line">char_temp &lt;&lt;= 8-code_len;       // 将编码字段从尾部移到字节的高位</span><br><span class="line">fwrite((char *)&amp;char_temp, sizeof(unsigned char), 1, outfile);       // 存入最后一个字节</span><br><span class="line">&#125;</span><br><span class="line">// 关闭文件</span><br><span class="line">fclose(infile);</span><br><span class="line">fclose(outfile);</span><br><span class="line">// 释放内存</span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i)</span><br><span class="line">free(huf_tree[i].code);</span><br><span class="line">free(huf_tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;//compress</span><br><span class="line"></span><br><span class="line">// 解压函数</span><br><span class="line">int extract(char *ifname, char *ofname)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i;</span><br><span class="line">unsigned long file_len;</span><br><span class="line">unsigned long writen_len = 0;// 控制文件写入长度</span><br><span class="line">FILE *infile, *outfile;</span><br><span class="line">unsigned int char_kinds;// 存储字符种类</span><br><span class="line">unsigned int node_num;</span><br><span class="line">HufTree huf_tree;</span><br><span class="line">unsigned char code_temp;// 暂存8bits编码</span><br><span class="line">unsigned int root;// 保存根节点索引，供匹配编码使用</span><br><span class="line">infile = fopen(ifname, &quot;rb&quot;);// 以二进制方式打开压缩文件</span><br><span class="line">// 判断输入文件是否存在</span><br><span class="line">if (infile == NULL)</span><br><span class="line">return -1;</span><br><span class="line">// 读取压缩文件前端的字符及对应编码，用于重建哈夫曼树</span><br><span class="line">fread((char *)&amp;char_kinds, sizeof(unsigned int), 1, infile);     // 读取字符种类数</span><br><span class="line">if (char_kinds == 1)</span><br><span class="line">&#123;</span><br><span class="line">fread((char *)&amp;code_temp, sizeof(unsigned char), 1, infile);     // 读取唯一的字符</span><br><span class="line">fread((char *)&amp;file_len, sizeof(unsigned long), 1, infile);     // 读取文件长度</span><br><span class="line">outfile = fopen(ofname, &quot;wb&quot;);// 打开压缩后将生成的文件</span><br><span class="line">while (file_len--)</span><br><span class="line">fwrite((char *)&amp;code_temp, sizeof(unsigned char), 1, outfile);</span><br><span class="line">fclose(infile);</span><br><span class="line">fclose(outfile);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">node_num = 2 * char_kinds - 1;// 根据字符种类数，计算建立哈夫曼树所需结点数 </span><br><span class="line">huf_tree = (HufNode *)malloc(node_num*sizeof(HufNode));// 动态分配哈夫曼树结点空间</span><br><span class="line">// 读取字符及对应权重，存入哈夫曼树节点</span><br><span class="line">for(i = 0; i &lt; char_kinds; ++i)     </span><br><span class="line">&#123;</span><br><span class="line">fread((char *)&amp;huf_tree[i].uch, sizeof(unsigned char), 1, infile);// 读入字符</span><br><span class="line">fread((char *)&amp;huf_tree[i].weight, sizeof(unsigned long), 1, infile);// 读入字符对应权重</span><br><span class="line">huf_tree[i].parent = 0;</span><br><span class="line">&#125;</span><br><span class="line">// 初始化后node_num-char_kins个结点的parent</span><br><span class="line">for(; i &lt; node_num; ++i) </span><br><span class="line">huf_tree[i].parent = 0;</span><br><span class="line">CreateTree(huf_tree, char_kinds, node_num);// 重建哈夫曼树（与压缩时的一致）</span><br><span class="line">// 读完字符和权重信息，紧接着读取文件长度和编码，进行解码</span><br><span class="line">fread((char *)&amp;file_len, sizeof(unsigned long), 1, infile);// 读入文件长度</span><br><span class="line">outfile = fopen(ofname, &quot;wb&quot;);// 打开压缩后将生成的文件</span><br><span class="line">root = node_num-1;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">fread((char *)&amp;code_temp, sizeof(unsigned char), 1, infile);// 读取一个字符长度的编码</span><br><span class="line">// 处理读取的一个字符长度的编码（通常为8位）</span><br><span class="line">for(i = 0; i &lt; 8; ++i)</span><br><span class="line">&#123;</span><br><span class="line">// 由根向下直至叶节点正向匹配编码对应字符</span><br><span class="line">if(code_temp &amp; 128)</span><br><span class="line">root = huf_tree[root].rchild;</span><br><span class="line">else</span><br><span class="line">root = huf_tree[root].lchild;</span><br><span class="line">if(root &lt; char_kinds)</span><br><span class="line">&#123;</span><br><span class="line">fwrite((char *)&amp;huf_tree[root].uch, sizeof(unsigned char), 1, outfile);</span><br><span class="line">++writen_len;</span><br><span class="line">if (writen_len == file_len) break;// 控制文件长度，跳出内层循环</span><br><span class="line">root = node_num-1;        // 复位为根索引，匹配下一个字符</span><br><span class="line">&#125;</span><br><span class="line">code_temp &lt;&lt;= 1;// 将编码缓存的下一位移到最高位，供匹配</span><br><span class="line">&#125;</span><br><span class="line">if (writen_len == file_len) break;// 控制文件长度，跳出外层循环</span><br><span class="line">&#125;</span><br><span class="line">// 关闭文件</span><br><span class="line">fclose(infile);</span><br><span class="line">fclose(outfile);</span><br><span class="line">// 释放内存</span><br><span class="line">free(huf_tree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;//extract()</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;朱安杰 194020215\n&quot;); </span><br><span class="line">int opt, flag  = 0;// 每次进入循环都要初始化flag为0</span><br><span class="line">char ifname[256], ofname[256];// 保存输入输出文件名</span><br><span class="line">// 输入所选择操作类型的数字代号：1：压缩，2：解压，3：退出</span><br><span class="line">printf(&quot;请输入操作所对应的数字:\n 1: 压缩\n 2: 解压\n 3: 退出\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;opt);</span><br><span class="line">if (opt == 3)</span><br><span class="line">break;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;请输入输入文件名: &quot;);</span><br><span class="line">fflush(stdin);// 清空标准输入流，防止干扰gets函数读取文件名</span><br><span class="line">gets(ifname);</span><br><span class="line">printf(&quot;请输入输出文件名: &quot;);</span><br><span class="line">fflush(stdin);</span><br><span class="line">gets(ofname);</span><br><span class="line">&#125;</span><br><span class="line">switch(opt)</span><br><span class="line">&#123;</span><br><span class="line">case 1: printf(&quot;压缩中……\n&quot;);</span><br><span class="line">flag = compress(ifname, ofname);// 压缩，返回值用于判断是否文件名不存在</span><br><span class="line">break;</span><br><span class="line">case 2: printf(&quot;解压中……\n&quot;);</span><br><span class="line">flag = extract(ifname, ofname);// 解压，返回值用于判断是否文件名不存在</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (flag == -1)</span><br><span class="line">printf(&quot;抱歉, 文件 \&quot;%s\&quot; 不存在!\n&quot;, ifname);// 如果标志为&#x27;-1&#x27;则输入文件不存在</span><br><span class="line">else</span><br><span class="line">printf(&quot;操作完成!\n&quot;);// 操作完成</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在霍夫曼编码这个实验中，我们需要将输入的任意一个源，运用Huffman编码压缩技术进行压缩，除此之外，我们还需要将压缩好的文件还原为原来的文件（即解压）。既然需要用哈夫曼编码解决问题，首先我们需将文件中出现的字符以及它们出现的次数写入配置文件中，构建哈夫曼树，而在构建哈夫曼树时，需要选出所给数据中最小的两个一步步的搭建，这是此次实验中要解决的一个问题之一。建好Huffman树后，要根据“左0右1”的方法对树进行编码，在这两个过程中，需要把文件当做“符号”来看待，“符号”确定为多少个也是值得思考的问题。做好哈夫曼树的构建以及哈夫曼编码后，我们需要在压缩文件中按顺序存入每个字符的Huffman编码对文件进行压缩。对于解压缩，我们需要利用配置文件重构Huffman树，那么这棵树如何重构也是有待于解决的。最后就是用主函数调用所有函数完成整个过程了，当然在主函数里，我们还需要利用分支来区分到底是压缩还是解压缩文件，有利于用户的选择。通过编写与学习huffman编码压缩与解压文件，我更清楚的认识了huffma编码的具体压缩程度，与压缩在实际之中的用法。也会在接下来的学习中有更多的思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/25/intervalscheduling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/25/intervalscheduling/" class="post-title-link" itemprop="url">区间调度IntervalScheduling</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-25 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-25T06:11:00+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int _count[100][100]; //构造最优矩阵</span><br><span class="line">int p[100][100];</span><br><span class="line">int numbers[100];</span><br><span class="line">void dp(int start[], int finish[],int TASK_COUNT) &#123;</span><br><span class="line">    for (int len = 2; len &lt;= TASK_COUNT + 2; len++) &#123;</span><br><span class="line">        for (int begin = 0; begin &lt;= TASK_COUNT + 1; begin++) &#123;</span><br><span class="line">            int end = begin + len - 1;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int slice = 0;</span><br><span class="line">            int k;</span><br><span class="line">            for (k = begin + 1; k &lt;= end - 1; k++) &#123;</span><br><span class="line">                if (start[k] &gt;= finish[begin]&amp;&amp;finish[k]&lt;=start[end]) &#123;</span><br><span class="line">                    int temp = _count[begin][k] + _count[k][end] + 1;</span><br><span class="line">                    if (temp &gt; max) &#123;</span><br><span class="line">                        max = temp;</span><br><span class="line">                        slice = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p[begin][end] = slice;</span><br><span class="line">            _count[begin][end] = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void printDp( int begin, int end) &#123;</span><br><span class="line">    int pos = p[begin][end];</span><br><span class="line">    if (pos == 0)</span><br><span class="line">        return;</span><br><span class="line">    cout &lt;&lt; numbers[pos] &lt;&lt; &quot; &quot;;</span><br><span class="line">    printDp(begin, pos);</span><br><span class="line">    printDp(pos, end);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">vector&lt;int&gt; vfinish;</span><br><span class="line">vector&lt;int&gt; vstart;</span><br><span class="line">//插入数组前置数值-1 </span><br><span class="line">vstart.push_back(-1);</span><br><span class="line">vfinish.push_back(-1);</span><br><span class="line">int number;</span><br><span class="line">cout &lt;&lt; &quot;请分别输入各个事件的开始跟结束时间：&quot; &lt;&lt; endl;</span><br><span class="line">while (1)&#123;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">vstart.push_back(number);</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">vfinish.push_back(number);</span><br><span class="line">if (cin.get() == &#x27;\n&#x27;)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//插入数组后置数值255 </span><br><span class="line">vstart.push_back(255);</span><br><span class="line">vfinish.push_back(255);</span><br><span class="line">int *start = new int[vstart.size()];</span><br><span class="line">    if (!vstart.empty())</span><br><span class="line">        memcpy(start, &amp;vstart[0], vstart.size()*sizeof(int));</span><br><span class="line">int *finish = new int[vfinish.size()];</span><br><span class="line">    if (!vfinish.empty())</span><br><span class="line">        memcpy(finish, &amp;vfinish[0], vfinish.size()*sizeof(int));</span><br><span class="line">int TASK_COUNT = vstart.size()-2;</span><br><span class="line">for(int i=0;i&lt;vstart.size();i++)</span><br><span class="line">numbers[i]=i;</span><br><span class="line">cout &lt;&lt; &quot;图例如下：&quot; &lt;&lt; endl; //输出图示</span><br><span class="line">    for (int i = 0; i &lt;= TASK_COUNT; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot;:&quot;;</span><br><span class="line">        for (int j = 0; j &lt; start[i]; j++) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = start[i]; j &lt; finish[i]; j++) </span><br><span class="line">            cout &lt;&lt; &quot;■&quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;TASK_COUNT+2;i++)&#123;//按照结束时间排序</span><br><span class="line">for(int j=0;j&lt;TASK_COUNT+1;j++)&#123;</span><br><span class="line">if(finish[j]&gt;finish[j+1])&#123;</span><br><span class="line">std::swap(finish[j],finish[j+1]);</span><br><span class="line">std::swap(start[j],start[j+1]);</span><br><span class="line">std::swap(numbers[j],numbers[j+1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    for (int i = 0; i &lt;= TASK_COUNT + 2; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= TASK_COUNT + 2; j++) &#123;</span><br><span class="line">            _count[i][j] = 0;</span><br><span class="line">            p[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(start, finish, TASK_COUNT);</span><br><span class="line">    cout &lt;&lt; &quot;总共可完成的事件个数为：&quot; &lt;&lt; _count[0][TASK_COUNT + 1] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;完成的事件为：&quot;;</span><br><span class="line">    printDp(0, TASK_COUNT + 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>区间调度的实验采用了结束时间先后为顺序排序。按照排序依次比较看事件是否匹配，如果匹配则加入。贪心算法，优先选择最早结束的需求，确保资源尽可能早地被释放，把留下来满足其他需求的时间最大化。具体伪代码如下所示，算法结束后集合A中会保留所有相容请求，A的大小即是最大相容数量。Aijj为Sij最优解，另其中的任务按照结束时间递增排序,令ak是Aij的第一个结束的任务,如果ak&#x3D;am,则证明成立。否则我们将ak用am替换，则它成为了另一个解A’ij，同样是最优解。所以即将任务以结束时间递增排序，第一个结束的任务一定在最优解中，依次找出子问题中最先结束，且开始时间在前一个解最后一个任务结束之间之后。复杂度为O(n)。同时很容易得出有递归和递推两种形式，一般采用递推。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/25/quicksort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/25/quicksort/" class="post-title-link" itemprop="url">快速排序QuickSort</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-25 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-25T06:11:00+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">//快速排序算法(从小到大)</span><br><span class="line">//arr:需要排序的数组，begin:需要排序的区间左边界，end:需要排序的区间的右边界</span><br><span class="line">void QuickSort(int *arr,int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line">//如果区间不只一个数</span><br><span class="line">if(begin &lt; end)&#123;</span><br><span class="line">int temp = arr[begin]; //将区间的第一个数作为基准数</span><br><span class="line">int i = begin; //从左到右进行查找时的“指针”，指示当前左位置</span><br><span class="line">int j = end; //从右到左进行查找时的“指针”，指示当前右位置</span><br><span class="line">//不重复遍历</span><br><span class="line">while(i &lt; j)&#123;</span><br><span class="line">//当右边的数大于基准数时，略过，继续向左查找</span><br><span class="line">//不满足条件时跳出循环，此时的j对应的元素是小于基准元素的</span><br><span class="line">while(i&lt;j &amp;&amp; arr[j] &gt; temp)</span><br><span class="line">j--;</span><br><span class="line">//将右边小于等于基准元素的数填入右边相应位置</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">//当左边的数小于等于基准数时，略过，继续向右查找</span><br><span class="line">//(重复的基准元素集合到左区间)</span><br><span class="line">//不满足条件时跳出循环，此时的i对应的元素是大于等于基准元素的</span><br><span class="line">while(i&lt;j &amp;&amp; arr[i] &lt;= temp)</span><br><span class="line">i++;</span><br><span class="line">//将左边大于基准元素的数填入左边相应位置</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">//将基准元素填入相应位置</span><br><span class="line">arr[i] = temp;</span><br><span class="line">//此时的i即为基准元素的位置</span><br><span class="line">//对基准元素的左边子区间进行相似的快速排序</span><br><span class="line">QuickSort(arr,begin,i-1);</span><br><span class="line">//对基准元素的右边子区间进行相似的快速排序</span><br><span class="line">QuickSort(arr,i+1,end);</span><br><span class="line">&#125;</span><br><span class="line">//如果区间只有一个数，则返回</span><br><span class="line">else</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//定义容器num存入原始数据 </span><br><span class="line">vector&lt;int&gt; num;//定义一个vector数组array</span><br><span class="line">int number;</span><br><span class="line">while (1) &#123;</span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">num.push_back(number);//每输入一个数字就把它添加到数组的最后</span><br><span class="line">if (cin.get() == &#x27;\n&#x27;)//如果是回车符则跳出循环</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">int n = num.size();//返回数组长度为len</span><br><span class="line">//将容器转换为int数组buffer </span><br><span class="line">int *buffer = new int[num.size()];</span><br><span class="line">    if (!num.empty())&#123;</span><br><span class="line">        memcpy(buffer, &amp;num[0], num.size()*sizeof(int));</span><br><span class="line">    &#125;</span><br><span class="line">//将数组参与排序 </span><br><span class="line">QuickSort(buffer,0,n-1);</span><br><span class="line">cout &lt;&lt; &quot;排序后的数组为：&quot; &lt;&lt; endl;</span><br><span class="line">//输出数组 </span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cout &lt;&lt; buffer[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>读取数组定义了一个vactor容器num，将数值存入容器后再将容器转换为普通数组buffer。函数排序定义了一个快速排序函数QuickSort，需要主函数的数组buffer，数组需要参与排序的第一个数字的下标，数组需要参与排序的最后一个数字的下标。在QuickSort函数中如果区间中不止一个数字，将区间的一个数作为基准数，定义从左到右进行查找时的“指针”i，指示当前左位置，定义从右到左进行查找时的“指针”j，指示当前右位置。当右边的数大于基准数时，略过，继续向左查找，不满足条件时跳出循环，此时的j对应的元素是小于基准元素的。在循环中将右边小于等于基准元素的数填入右边相应位置，当左边的数小于等于基准数时，略过，继续向右查找(重复的基准元素集合到左区间)不满足条件时跳出循环，此时的i对应的元素是大于等于基准元素的。将左边大于基准元素的数填入左边相应位置。然后将基准元素填入相应位置。最后，对基准元素的左边和右边子区间进行相似的快速排序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/25/stablemaching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/25/stablemaching/" class="post-title-link" itemprop="url">稳定匹配StableMaching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-25 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-25T06:11:00+08:00">2021-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define MAX 10      //医院学生最多为MAX个 </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int hospital_num, student_num;    //医院学生的个数，需要输入 </span><br><span class="line">    int HospitalPref[MAX][MAX], StudentPref[MAX][MAX];     //喜欢序列，需要输入（用数字表示医院学生） </span><br><span class="line">    int HospitalInverse[MAX][MAX], StudentInverse[MAX][MAX]; </span><br><span class="line">    int confernstudent[MAX], confernhospital[MAX];    //表示各个配对 </span><br><span class="line">    int count[MAX];    // count[m]表示m提出配对的次数 </span><br><span class="line">    queue&lt;int&gt; FreeHospitals;   // 表示未被配对的医院 </span><br><span class="line">    cout &lt;&lt; &quot;请输入医院或学生的总数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; hospital_num;</span><br><span class="line">    student_num = hospital_num;</span><br><span class="line">    for (int i = 0; i &lt; hospital_num; i++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i+1 &lt;&lt; &quot;个医院的喜好排序&quot; &lt;&lt; endl;</span><br><span class="line">        FreeHospitals.push(i);</span><br><span class="line">        for (int j = 0; j &lt; student_num; j++)&#123;</span><br><span class="line">            cin &gt;&gt; HospitalPref[i][j];</span><br><span class="line">            HospitalPref[i][j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; student_num; i++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i+1 &lt;&lt; &quot;个学生的喜好排序&quot; &lt;&lt; endl;</span><br><span class="line">        for (int j = 0; j &lt; hospital_num; j++)&#123;</span><br><span class="line">            cin &gt;&gt; StudentPref[i][j];</span><br><span class="line">            StudentPref[i][j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; hospital_num; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; student_num; j++)&#123;</span><br><span class="line">            HospitalInverse[i][HospitalPref[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; student_num; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; hospital_num; j++)&#123;</span><br><span class="line">            StudentInverse[i][StudentPref[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化每个医院和学生的状态，并将每个医院提出配对的次数赋值成0 </span><br><span class="line">    for (int i = 0; i &lt; hospital_num; i++)&#123;</span><br><span class="line">        confernstudent[i] = -1;</span><br><span class="line">        confernhospital[i] = -1;</span><br><span class="line">        count[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 当FreeHospitals的队列为空时结束循环 </span><br><span class="line">    while(FreeHospitals.size() != 0)&#123;</span><br><span class="line">        // 取出队列中的第一个医院，hospital代表该医院的序号 </span><br><span class="line">        int hospital = FreeHospitals.front();</span><br><span class="line">        // 医院按照自己的喜欢序列降序对学生提出配对直到医院被配对 </span><br><span class="line">        for (int i = count[hospital]; i &lt; student_num; count[hospital]++, i++)&#123;</span><br><span class="line">            // 如果这个学生未被配对 </span><br><span class="line">            if (confernstudent[HospitalPref[hospital][i]] == -1)&#123;</span><br><span class="line">                confernstudent[HospitalPref[hospital][i]] = hospital;</span><br><span class="line">                confernhospital[hospital] = HospitalPref[hospital][i];   //将医院学生配对 </span><br><span class="line">                FreeHospitals.pop();   // 将该医院从队列删除 </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果学生较之已配对医院更喜欢这个医院 </span><br><span class="line">            else if (StudentInverse[hospital] &lt; StudentInverse[confernstudent[HospitalPref[hospital][i]]])&#123;</span><br><span class="line">                FreeHospitals.push(confernstudent[HospitalPref[hospital][i]]); //将原配对医院加入未配对医院队列 </span><br><span class="line">                confernhospital[confernstudent[HospitalPref[hospital][i]]] = -1; //将医院的状态设置成未配对</span><br><span class="line">//（也可以不用设置） </span><br><span class="line">                confernstudent[HospitalPref[hospital][i]] = hospital;</span><br><span class="line">                confernhospital[hospital] = HospitalPref[hospital][i];       //重新配对 </span><br><span class="line">                FreeHospitals.pop();  // 将该医院从队列删除  </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 否则学生拒绝医院的配对 </span><br><span class="line">            else &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; hospital_num; i++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;医院&quot; &lt;&lt; i+1 &lt;&lt; &quot;-----学生&quot; &lt;&lt; confernhospital[i]+1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>稳定匹配算法的实现我采用的是c++语言。在程序中，将医院与学生的喜好和医院与学生实际的匹配结果分别建立了四个二维数组；定义了配对次数和一个表示未配对医院的线性表。<br>程序首先读取医院（学生）的总数，再依次读取每个医院和学生的喜好排序，然后初始化每个医院和学生的状态，并将每个医院提出配对的次数赋值成0。进入循环依次取出队列中的第一个医院， 医院按照自己的喜欢序列降序对学生提出配对直到医院被配对，如果这个学生未被配对，将医院学生配对，将该医院从队列删除，如果学生较之已配对医院更喜欢这个医院，则将原配对医院加入未配对医院队列且医院的状态设置成未配对。待FreeHospitals的队列为空时结束循环后输出匹配结果。<br>程序使用了线性表queue，相比于数组而言大大缩短了运行所需时间。然而，在这样的场景中G-S匹配并不是公平的，由于每次迭代按照M中递减偏好尝试匹配，它是一种偏向于M节点的算法。算法产出的稳态匹配结果，所有的学校都匹配了尽可能好好的结果，而所有学生都匹配了尽可能不好的结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/20/deadline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/20/deadline/" class="post-title-link" itemprop="url">算法分析与设计大作业——截止日期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-20 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-20T06:11:00+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h2><p>某学科老师布置了n个题目，每个题目都有相应的分数及截止日期。各个题目的分数及截止日期可能并不相同。对某题目而言，如果在该题目的截止日期前完成则可获得对应的分数，否则无法得分。假设每个题目均需要花费一天的时间来完成，这期间无法完成其他题目。请你设计算法指定题目的完成计划，从而使总的得分最大。 下面给出一个包含了7个题目及相应的分数、截止日期的实例：  </p>
<p>题目</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>分数</p>
<p>6</p>
<p>7</p>
<p>2</p>
<p>1</p>
<p>4</p>
<p>5</p>
<p>1</p>
<p>截止日期（天）</p>
<p>1</p>
<p>1</p>
<p>3</p>
<p>3</p>
<p>2</p>
<p>2</p>
<p>4</p>
<p>对该实例而言，得分最大的作业完成方案为花费4天时间依次完成题目2,6,3,7。得分为15。</p>
<p>【输入形式】<br>输入数据第一行为一个整数n (0 &lt;&#x3D; n &lt;&#x3D; 10000), 表示题目数目 之后n行各有两个整数, 第i行为 pi, di (1 &lt;&#x3D; pi, di &lt;&#x3D; 10000)，分别表示第i个题目的分数和截止时间<br>【输出形式】<br>一个整数, 为当前条件下的最大得分<br>【样例输入】<br>4<br>50 2<br>10 1<br>20 2<br>30 1<br>【样例输出】<br>80</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><p>本题适合用贪心算法来求解，先按照任务价值从大到小排序，然后依次取出后对任务进行判断。如果取出任务截至当天未被占用，则将该任务价值加入总价值后将当天标记为占用。如果之前判断的时间被占用，则往前推算一天后再进行判断。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><strong>伪代码</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对于i = 0 ~ n&#123;</span><br><span class="line">如果任务i截止日期当天没有被占用&#123;</span><br><span class="line">结果加上第i个任务的分数</span><br><span class="line">任务i截止日期当天标记为已被占用;</span><br><span class="line">&#125;</span><br><span class="line">如果任务截止日期当天被占用&#123;</span><br><span class="line">对于j = 任务i截止日期-1 ~ 0)&#123;</span><br><span class="line">如果第j天被占用&#123;</span><br><span class="line">结果加上第i个任务的分数</span><br><span class="line">第j天标记为已被占用</span><br><span class="line">跳出循环</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码（JAVA1）"><a href="#代码（JAVA1）" class="headerlink" title="代码（JAVA1）"></a><strong>代码（JAVA1）</strong></h2><h3 id="deadline类："><a href="#deadline类：" class="headerlink" title="deadline类："></a>deadline类：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class deadline &#123;</span><br><span class="line">int score;</span><br><span class="line">int day;</span><br><span class="line">public deadline(int score,int day) &#123;</span><br><span class="line">this.score = score;</span><br><span class="line">this.day = day;</span><br><span class="line">&#125;</span><br><span class="line">public int getScore() &#123;</span><br><span class="line">return score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="test类："><a href="#test类：" class="headerlink" title="test类："></a>test类：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class test&#123;</span><br><span class="line">public static void Sort(deadline[] overdays) &#123;</span><br><span class="line">Arrays.sort(overdays, new Comparator&lt;deadline&gt;() &#123;</span><br><span class="line">   public int compare(deadline o1, deadline o2) &#123;</span><br><span class="line">    return (int) (o2.getScore() - o1.score);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">int n,a,b,number=0,count=0;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">n=input.nextInt();</span><br><span class="line">if(n==0)&#123;</span><br><span class="line">System.out.println(&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">deadline[] overdays = new deadline[n];</span><br><span class="line">for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">overdays[i]=new deadline(input.nextInt(),input.nextInt());</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">Sort(overdays);</span><br><span class="line">int max=overdays[0].day;</span><br><span class="line">for (int i=1;i&lt;n;i++)&#123;</span><br><span class="line">if(max&lt;overdays[i].day)</span><br><span class="line">max=overdays[i].day;</span><br><span class="line">&#125;</span><br><span class="line">int[] days = new int[max+1];</span><br><span class="line">for (int i=0;i &lt;= max;i++)</span><br><span class="line">days[i]=1;</span><br><span class="line">for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(days[overdays[i].day]==1)&#123;</span><br><span class="line">number+=overdays[i].score;</span><br><span class="line">days[overdays[i].day]=0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int j=overdays[i].day-1;j&gt;0;j--)&#123;</span><br><span class="line">if(days[j]==1)</span><br><span class="line">&#123;</span><br><span class="line">number+=overdays[i].score;</span><br><span class="line">days[j]=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码（JAVA2）"><a href="#代码（JAVA2）" class="headerlink" title="代码（JAVA2）"></a>代码（JAVA2）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class deadline &#123;</span><br><span class="line">public static int maxinarr(int[] a,int len) &#123;</span><br><span class="line">int max = a[0];</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">if(max&lt;a[i])</span><br><span class="line">max = a[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">public static void swaparr(int a[], int b[], int len) &#123;</span><br><span class="line">int k;</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;len-1;j++)&#123;</span><br><span class="line">if(a[j]&lt;a[j+1])&#123;</span><br><span class="line">k=a[j];</span><br><span class="line">a[j]=a[j+1];</span><br><span class="line">a[j+1]=k;</span><br><span class="line">k=b[j];</span><br><span class="line">b[j]=b[j+1];</span><br><span class="line">b[j+1]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static boolean judge(int day[], int data[], int n) &#123;</span><br><span class="line">boolean ret = false;</span><br><span class="line">for(int i=data[n]-1;i&gt;=0;i--)&#123;</span><br><span class="line">if(day[i]==0)&#123;</span><br><span class="line">day[i]=1;</span><br><span class="line">ret = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">n = input.nextInt();</span><br><span class="line">int[] score = new int[n];//成绩 </span><br><span class="line">int[] data = new int[n];//截止日期 </span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">score[i] = input.nextInt();</span><br><span class="line">data[i] = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">swaparr(score, data, n);</span><br><span class="line">int a=maxinarr(data,n); </span><br><span class="line">int allscore=0;</span><br><span class="line">int[] day = new int[a];//每天任务情况</span><br><span class="line">for(int i=0;i&lt;a;i++)&#123;</span><br><span class="line">day[i]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(judge(day,data,i))&#123;</span><br><span class="line">allscore += score[i];</span><br><span class="line">a--;</span><br><span class="line">if(a==-1)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(allscore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码（C-1）"><a href="#代码（C-1）" class="headerlink" title="代码（C++1）"></a>代码（C++1）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//定义结构体用来存放题目分数及截止日期</span><br><span class="line">struct sdata&#123;</span><br><span class="line">int score;</span><br><span class="line">int deadline;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用来给结构体内数据按照成绩排序 </span><br><span class="line">void arrSort(sdata* pData, int length)&#123;</span><br><span class="line">sdata temp;</span><br><span class="line">for (int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">for (int j = 0; j &lt; length-1; j++)&#123;</span><br><span class="line">if (pData[j].score &lt; pData[j+1].score)&#123;</span><br><span class="line">   temp = pData[j];</span><br><span class="line">   pData[j] = pData[j+1];</span><br><span class="line">   pData[j+1] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">int answer = 0;</span><br><span class="line">int x = 0;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">//输入值n总天数如果为0则不需要计算 </span><br><span class="line">if(n==0)&#123;</span><br><span class="line">cout &lt;&lt; &quot;0&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">sdata *Data = new sdata[n];</span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">//如果题目分数或者截止日期存在0，则该条数据无效 </span><br><span class="line">if(a*b==0)&#123;</span><br><span class="line">x++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">Data[i].score=a; Data[i].deadline=b;</span><br><span class="line">&#125;</span><br><span class="line">n -= x;</span><br><span class="line"></span><br><span class="line">//排序 </span><br><span class="line">arrSort(Data, n);</span><br><span class="line">//寻需要最大时间的任务的天数max </span><br><span class="line">int max=Data[0].deadline;</span><br><span class="line">for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">if(max&lt;Data[i].deadline)</span><br><span class="line">max=Data[i].deadline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据max定义并且初始化时间表 </span><br><span class="line">int schedule[max+1]; </span><br><span class="line">for (int i = 0; i &lt;= max; i++)</span><br><span class="line">schedule[i]=1;</span><br><span class="line"></span><br><span class="line">//计算过程（根据分数从大到小遍历每个任务） </span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">//如果任务截止日期当天没有被占用 </span><br><span class="line">if(schedule[Data[i].deadline]==1)&#123;</span><br><span class="line">answer += Data[i].score;</span><br><span class="line">schedule[Data[i].deadline]=0;</span><br><span class="line">&#125;</span><br><span class="line">//如果任务截止日期当天被占用</span><br><span class="line">else&#123;</span><br><span class="line">for(int j=Data[i].deadline-1;j&gt;0;j--)&#123;</span><br><span class="line">if(schedule[j]==1)&#123;</span><br><span class="line">answer+=Data[i].score;</span><br><span class="line">schedule[j]=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; answer;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码（C-2）"><a href="#代码（C-2）" class="headerlink" title="代码（C++2）"></a>代码（C++2）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//将两个数组按照前面数组的降序排列(数组a，数组b，数组长度len)</span><br><span class="line">void swaparr(int a[], int b[], int len)&#123;</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;len-1;j++)&#123;</span><br><span class="line">if(a[j]&lt;a[j+1])&#123;</span><br><span class="line">swap(a[j],a[j+1]);</span><br><span class="line">swap(b[j],b[j+1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//寻找数组中数字最大值(数组a，数组a长度len) </span><br><span class="line">int maxinarr(int a[],int len)&#123;</span><br><span class="line">int max = a[0];</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">if(max&lt;a[i])</span><br><span class="line">max = a[i];</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">bool judge(int day[], int data[], int n)&#123;</span><br><span class="line">bool ret=0;</span><br><span class="line">for(int i=data[n]-1;i&gt;=0;i--)&#123;</span><br><span class="line">if(day[i]==0)&#123;</span><br><span class="line">day[i]=1;</span><br><span class="line">ret = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int score[n];//成绩 </span><br><span class="line">int data[n];//截止日期 </span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">cin &gt;&gt; score[i];</span><br><span class="line">cin &gt;&gt; data[i];</span><br><span class="line">&#125;</span><br><span class="line">swaparr(score, data, n);</span><br><span class="line">int a=maxinarr(data,n); </span><br><span class="line">int allscore=0;</span><br><span class="line">int day[a];//每天任务情况</span><br><span class="line">for(int i=0;i&lt;a;i++)&#123;</span><br><span class="line">day[i]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(judge(day,data,i))&#123;</span><br><span class="line">allscore += score[i];</span><br><span class="line">a--;</span><br><span class="line">if(a==-1)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; allscore;</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="算法正确性分析"><a href="#算法正确性分析" class="headerlink" title="算法正确性分析"></a><strong>算法正确性分析</strong></h2><p>本算法对规定范围下不同的输入数据能够得出满足要求的结构，对于精心选择的典型、苛刻而带有刁难性的输入数据能够得出满足要求的结果，对于一切合法的输入数据都产生满足要求的结果。<br>对于核心算法，先按照任务价值从大到小排序，然后依次取出后对任务进行判断。如果取出任务截至当天未被占用，则将该任务价值加入总价值后将当天标记为占用。如果取出任务截止当天被占用，则往前推算一天进行判断。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本题采用贪心算法，通过这次学习，我了解到贪心算法需要建立数学模型来描述问题；把求解的问题分成若干个子问题；对每一子问题求解，得到子问题的局部最优解；把子问题的解局部最优解合成原来解问题的一个解。解决问题需要从问题的某个初始解出发，采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模，最后将所有部分解综合起来，得到问题的最终解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2021/05/20/finaltest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2021/05/20/finaltest/" class="post-title-link" itemprop="url">算法分析与设计大作业——期末测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-05-20 06:11:00" itemprop="dateCreated datePublished" datetime="2021-05-20T06:11:00+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>需要代码请评论或者与我联系！</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>助教小明给期末测验出了n道算法题目。他希望在即将到来的期末测验试卷中使用其中k道题目。每道算法题目都有一个难度等级。如果一次测验中的所有k道题目都有不同的难度等级，那么这次期末测试就是有区分度的。计算小明可以设计多少种有区分度的期末试卷。<br>注：两份测验试卷当且仅当一份试卷中存在某一题目p，而另一份试卷中不存在这个题p，这两份试卷才有区别。<br>输出结果对998,244,353取余。</p>
<h2 id="输入形式"><a href="#输入形式" class="headerlink" title="输入形式"></a>输入形式</h2><p>输入第一行包括两个用空格分隔开的整数n和k，1≤k≤n≤1000<br>输入第二行n个用空格分开隔的整数li，表示不同题目的难度，Li≤109</p>
<h2 id="输出形式"><a href="#输出形式" class="headerlink" title="输出形式"></a>输出形式</h2><p>一个整数，表示可设计的有区分度的期末试卷数目。结果对998,244,353取余</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 2<br>1 2 3 4 5</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>10</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该题可采用动态规划算法来进行求解。首先将题目进行整理，按照题目难度排序后整理出不同难度的题目的个数，最后利用列表格动态规划求解出最终结果。或者利用递归和数学计算的方式求解，但是这种方式对于计算机计算需要大量的空间，解法不是最优。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h2><p><img src="https://img-blog.csdnimg.cn/20210520201132837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JhbmRhbGxDaHU=,size_16,color_FFFFFF,t_70"></p>
<p>流程图</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><strong>伪代码</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">枚举i=1~count&#123;</span><br><span class="line">枚举j=0~i&#123;</span><br><span class="line">如果j=0成立&#123;</span><br><span class="line">sheet[i][j]=number[i][1]+sheet[i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">如果i==j成立&#123;</span><br><span class="line">sheet[i][j]=(number[i][1]*sheet[i-1][j-1]) %998244353;</span><br><span class="line">&#125;</span><br><span class="line">否则&#123;</span><br><span class="line">sheet[i][j]=(sheet[i-1][j]+sheet[i-1][j-1]*number[i][1]) %998244353;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a><strong>代码（C++）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long number[1000][2];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">long long n,k;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">long long data[n];</span><br><span class="line">for(long long i=0;i&lt;n;i++)&#123;</span><br><span class="line">cin &gt;&gt; data[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(data, data+n);</span><br><span class="line">number[0][0]=data[0];</span><br><span class="line">number[0][1]=1;</span><br><span class="line">long long  count=1;</span><br><span class="line">for(long long i=1;i&lt;n;i++)&#123;</span><br><span class="line">if(data[i]==data[i-1])&#123;</span><br><span class="line">number[count-1][1]++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">number[count][0]=data[i];</span><br><span class="line">number[count][1]=1;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(long long i=0;i&lt;count;i++)&#123;</span><br><span class="line">cout &lt;&lt; number[i][0] &lt;&lt; &quot; &quot; &lt;&lt;  number[i][1] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(count&lt;k)&#123;</span><br><span class="line">cout &lt;&lt; &quot;0&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long sheet[count][k];</span><br><span class="line">sheet[0][0]=number[0][1];</span><br><span class="line"></span><br><span class="line">for(long long i=1;i&lt;count;i++)&#123;</span><br><span class="line">for(long long j=0;j&lt;k;j++)&#123;</span><br><span class="line">if(j==0)&#123;</span><br><span class="line">sheet[i][j]=number[i][1]+sheet[i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">else if(i==j)&#123;</span><br><span class="line">sheet[i][j]=(number[i][1]*sheet[i-1][j-1])%998244353;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">sheet[i][j]=(sheet[i-1][j]+sheet[i-1][j-1]*number[i][1])%998244353;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long suma=sheet[count-1][k-1];</span><br><span class="line"></span><br><span class="line">//long long sum=jc(count)/(jc(k)*jc(count-k));</span><br><span class="line">//</span><br><span class="line">//for(long long i=0;i&lt;count;i++)&#123;</span><br><span class="line">//sum=sum*(long long)number[i][1];</span><br><span class="line">//&#125;</span><br><span class="line">//cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">suma=suma%998244353; </span><br><span class="line">cout &lt;&lt; suma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本算法对规定范围下不同的输入数据能够得出满足要求的结构，对于精心选择的典型、苛刻而带有刁难性的输入数据能够得出满足要求的结果，对于一切合法的输入数据都产生满足要求的结果。本算法要求考虑到边界条件当不同难度的算法题目数量小于要求。本算法的边界条件就是不同难度的题目数量可能会小于所需求的k，本程序以及提前判断出相关大小情况。<br>核心代码问题：求解sheet表中第一列就是上一行的数值加上number[i][1]的值；求解sheet表中左上到右下的对角线上的格子的值sheet[i][j]就是number[i][1]乘上sheet[i-1][j-1]；求解其他的格子中的值就是sheet[i-1][j]加上sheet[i-1][j-1]乘以number[i][1]（n类里面挑选k个的个数等同于n-1类里挑选k个的个数或者n-1类里挑选k-1个，再在第n类挑选一个）。</p>
<p> </p>
<p>1</p>
<p>2</p>
<p>…</p>
<p>k-1</p>
<p>k</p>
<p>…</p>
<p>1</p>
<p>number[1][1]</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>2</p>
<p>sheet[1][1]+number[1][1]</p>
<p>sheet[1][1]*number[2][1]</p>
<p> </p>
<p> </p>
<p>  </p>
<p> </p>
<p>…</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<p> </p>
<p>n-1</p>
<p>sheet[n-1][1]</p>
<p>sheet[n-1][2]</p>
<p>sheet[n-1][k-1]</p>
<p>sheet[n-1][k]</p>
<p> </p>
<p>n</p>
<p>sheet[n-1][1]+number[n][1]</p>
<p>sheet[n-1][2]+sheet[n-1][1]* number[n][1]</p>
<p> </p>
<p>sheet[n-1][k-1]+ sheet[n-1][k-2]* number[n][1]</p>
<p>sheet[n-1][k]+ sheet[n-1][k-1]* number[n][1]</p>
<p>   </p>
<p>…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zhuanjier.github.io/blog/2020/06/27/experimentalreportonprogramdesigninspring20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="转接">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="转接的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/27/experimentalreportonprogramdesigninspring20/" class="post-title-link" itemprop="url">20春小学期程序设计实验报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-06-27 06:11:00" itemprop="dateCreated datePublished" datetime="2020-06-27T06:11:00+08:00">2020-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2022-07-10 14:37:47" itemprop="dateModified" datetime="2022-07-10T14:37:47+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
                  . 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Experimental report on program design in spring 20</p>
<h1 id="1-最长公字串"><a href="#1-最长公字串" class="headerlink" title="1. 最长公字串"></a>1. 最长公字串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，对输入的字符串s和t，求其最长的公共子字符串。输入形式：从屏幕分行读入串s和t。s和t由任意字符构成，长度都不超50个字符。输入数据确保只有唯一的最长公共子串。如果没有公共子串，打印No Answer。</p>
<p>输出形式：在单独行上输出串s和串t的最长公共子串，在结尾输出一个回车符。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据题意，将对应的行内字符串存入对应的数组a，b中，再比较a和b的长度，将较短的信息存入a，较长的存入b中。将a中以依次减少1个长度的原则取出对应的数组存入test数组中，再在b中取出相同长度的数组存入card数组中，比较test和card的区别来判断是否存在最大相同子串，如果相同就输出该子串，并且离开循环。如果最后循环完还未输出就输出No Answer。</p>
<h2 id="代码（c）"><a href="#代码（c）" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">char *mystrncpy(char *string, int n)&#123;//指向字符串的指针可以改变 </span><br><span class="line">char*p=string;</span><br><span class="line">if(p==NULL)&#123;//如果截取的字符串是空的直接返回</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int i=0;</span><br><span class="line">while(*p!=&#x27;\0&#x27;)&#123;//循环直到达n个字符串终止</span><br><span class="line">if(i==n)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line">*(p++)=&#x27;\0&#x27;;//赋值结束字符串</span><br><span class="line">return string;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">char a[50],b[50];</span><br><span class="line">char c[50];//中间变量 </span><br><span class="line">int flag=0;</span><br><span class="line">int i,j,k,m,n;</span><br><span class="line">gets(a);//第一行字符串 </span><br><span class="line">gets(b);//第二行字符串 </span><br><span class="line">int lentha=strlen(a);//第一行字符串长度 </span><br><span class="line">int lenthb=strlen(b);//第二行字符串长度 </span><br><span class="line">/*检测输入*/ </span><br><span class="line">//printf(&quot;%s&quot;,a); </span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">//printf(&quot;%s&quot;,b);</span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">//printf(&quot;lentha=%d,lenthb=%d&quot;,lentha,lenthb);</span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">/*初处理数据，将短的的数据变到a*/</span><br><span class="line">if(lentha&gt;lenthb)&#123;</span><br><span class="line">for(i=0;i&lt;50;i++)&#123;</span><br><span class="line">c[i]=a[i];</span><br><span class="line">a[i]=b[i];</span><br><span class="line">b[i]=c[i];</span><br><span class="line">&#125;</span><br><span class="line">i=lentha;</span><br><span class="line">lentha=lenthb;</span><br><span class="line">lenthb=i; </span><br><span class="line">&#125;</span><br><span class="line">/*初处理检测*/ </span><br><span class="line">//printf(&quot;初处理%s&quot;,a); </span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">//printf(&quot;初处理%s&quot;,b);</span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">//printf(&quot;初处理lentha=%d,lenthb=%d&quot;,lentha,lenthb);</span><br><span class="line">//printf(&quot;\n-------------------------\n&quot;);</span><br><span class="line">/*运算部分*/ </span><br><span class="line">for(i=lentha;i&gt;0;i--)&#123;//从a的最长长度截取，依次减少 </span><br><span class="line">char test[i];//对应a中取得的值 </span><br><span class="line">char card[i];//对应b中取得的值 </span><br><span class="line">for(j=0;j&lt;=lentha-i;j++)&#123;</span><br><span class="line">for(k=0;k&lt;i;k++)&#123;//将a中对应值覆到test </span><br><span class="line">test[k]=a[k+j];</span><br><span class="line">&#125;</span><br><span class="line">for(m=0;m&lt;lenthb-i+1;m++)&#123;</span><br><span class="line">for(n=0;n&lt;i;n++)&#123;//将b中对应值覆到card </span><br><span class="line">card[n]=b[n+m];</span><br><span class="line">&#125;</span><br><span class="line">int judge=1; </span><br><span class="line">for(n=0;n&lt;i;n++)&#123;//判断card和test是否一致 </span><br><span class="line">if(test[n]!=card[n])&#123;</span><br><span class="line">judge=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(judge)&#123;</span><br><span class="line">printf(&quot;%s&quot;,mystrncpy(test,i));</span><br><span class="line">flag=1;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">break; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==0)&#123;</span><br><span class="line">printf(&quot;No Answer&quot;); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题用到了get();来获取字符串。gets()用于从标准输入流stdin读入一个整行（以bai’\n’或EOF）结束，写入ptr指向的字符数组，并返回这个指针；出错或遇到文件结束时则返回NULL。行末的’\n’从流中取出，但不写入数组。gets()不检查被写入的数组大小。程序运用逐个尝试的方法来获取最长公子串。在获取字符串时检查字符串长度，当a的长度大于b的长度时，运用了逐个代换的方法，将a，b中的元素互换位置。</p>
<h1 id="2-CCF-201712-5-商路"><a href="#2-CCF-201712-5-商路" class="headerlink" title="2. CCF 201712-5 商路"></a>2. CCF 201712-5 商路</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>国王小w总共有八座城市，用1到n的整数编号。除首都1号城市外，每座城市都有唯一的直接上级城市，并有一条道路连接二者，即这些城市和道路构成了一棵有根树。对于城市i，我们记它的直接上级城市为ui，它到该城市道路的长度为si；同时，称i是么ui的直接下级城市。城市i的直接下级城市和直接下级城市的下级城市统称为城市i的下级城市。<br>每座城市的长官都想要建立一条由自己管辖的商路。对于城市i的长官，他管辖的商路必须形如a1a2…ak，其中a1&#x3D;i：对于1≤j&lt;k,aj+1是aj的下级城市：k可以是你指定的正整数。即，一条商路是从城市i出发，依次向下级延伸的一条路径。注意路径只用向下级城市延伸即可，不限定为直接下级。城市i的价值由vi和fi两个参数描述。商路a1a2…ak的总价值为：</p>
<p><img src="http://blog.zhuanjie.ltd/wp-content/uploads/2022/02/%E5%9B%BE%E7%89%871.png"></p>
<p>其中d(aj.aj+1）是连接aj和aj+1的道路总长度。形象地说，商路的总价值等于每小段的价值之和：vi和fi分别描述了i作为起点的最理想小段价值和最佳的小段长度：小段的价值等于以它们为参数，两座城市距离为自变量的二次函数。<br>如有必要，一条商路允许只包含长官所在的那一座城市，即k&#x3D;1，此时商路的总价值为0。此外，不同城市长官建立的道路之间互相不影响，价值独立计算。<br>国王小W希望所有的n条商路的总价值之和最大，他现在请你帮忙。你可以替每座城市的长官决定商路的长度k和路径上除起点之外的城市，问最大的总价值之和是多少。</p>
<p>输入格式<br>从标准输入读入数据。<br>输入的第一行包含一个正整数个，表示数据的组数。对于测试数据，保证T&#x3D;10。<br>接下来有T个部分，每个部分描述一组数据，其中：<br>每个部分第一行包含一个正整数n，表示城市的数量。<br>接下米n行，每行包含4个非负整数ui，si,vi,fi，分别表示直接上级城市的编号，连接直接上级城市道路的长度，最理想小段价值和最佳的小段长度。保证：0≤vi≤10^13，0≤fi≤10^9；对于2≤i≤n，保证1≤ui&lt;i,1≤si≤10^4；u1&#x3D;s1&#x3D;0，仅占位无实际意义（首都没有上级城市）。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>根据题意输入的顺序是城市编号的顺序，而城市编号的顺序又直接决定了城市之间的上下级关系。虽然编号小的不一定是大编号的下级，但下级城市的编号一定比上级城市的编号小，如何利用这一点非常重要。假如城市A的下级城市是B,C,D ；那如果B,C,D 本身的商路价值都是最大话之后，A 只能在B,C,D 中挑选一个与之相连，或者不相连，来使自己的商路价值最大话。也就是如果B,C,D的商路价值都是已知的了，那A 的商路价值就都是已知的了。 如此以来，只需要按照逆序从后向前分别计算商路的最大值就可以了。</p>
<h2 id="代码（c-）"><a href="#代码（c-）" class="headerlink" title="代码（c++）"></a>代码（c++）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll MOD=1e18;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">ll v[N],f[N],u[N],s[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">memset(ans,0,sizeof(ans));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T,n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">init(); //初始化 </span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d%d%d&quot;,&amp;u[i],&amp;s[i],&amp;v[i],&amp;f[i]);</span><br><span class="line">vis[u[i]]++; //vis数组保存这个点的直接下级数量 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++) //这里类似拓扑排序，直接下级数量为零入队 </span><br><span class="line">if(!vis[i]) q.push(i);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int k=q.front();q.pop();</span><br><span class="line">int t=u[k],d=s[k];</span><br><span class="line">vis[t]--;</span><br><span class="line">if(!vis[t]) q.push(t);//直接下级全都处理过了，入队 </span><br><span class="line">while(t) //寻找所有上级，计算上级城市到这里的获利，取最大值 </span><br><span class="line">&#123;</span><br><span class="line">ans[t]=max(ans[t],(ans[k]+v[t]-(f[t]-d)*(f[t]-d))); //ans里保存了以这个城市为开头的商路最大价值 </span><br><span class="line">d+=s[t];</span><br><span class="line">t=u[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) sum=(sum+ans[i])%MOD; //计算总价值 </span><br><span class="line">printf(&quot;%lld\n&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>此程序涉及到了未学过的知识点，了解了拓扑排序。由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p>
<h1 id="3-Vigenere加密算法"><a href="#3-Vigenere加密算法" class="headerlink" title="3. Vigenere加密算法"></a>3. Vigenere加密算法</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>单一字母替换密码很容易通过字母频率分析而破解。而一种被称为Vigenere的密码克服了这一缺点，其方法是对于待加密信息中不同位置上的字母应用不同的字母加密对应关系。首先选择一个密钥，例如TIGER，然后，对于待加密信息中的第一个字符，采用如下的字母对应关系加密：上述加密字母表是经过固定移位的字母表，其首字母是T（TIGER的首字母，先是T～Z，然后是A～S）。例如：字母A加密转换成T，字母Q转换成J，不在A～Z之间的字符，不进行转换。对待加密信息中的第二个字符，采用如下的字母对应关系加密：</p>
<p>对于待加密信息的第3个、第4个、第5个字符，分别采用以G、E、R开头的移位字母表对其加密。因为密钥只有5个字母长，所以对于待加密信息中的第6个字符，将采用与第1个字符相同的对应关系加密，以此类推。假定待加密信息中的字母全为大写字母，并且输入的密钥也全为大写字母；密钥长度不超过20，待加密信息不超过200个字符。</p>
<p>输入形式：从标准输入中输入密钥串，然后在下一行输入待加密信息（末尾有回车换行）。</p>
<p>输出形式：加密后结果输出到标准输出（末尾要有回车换行）。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>由题意，创建两个数组，依次存放密钥跟密文，再利用循环依次获取每一位的加密后的文字并输出。如果不在A~Z之间就直接输出。</p>
<h2 id="代码（c）-1"><a href="#代码（c）-1" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char key[20];</span><br><span class="line">char mas[200];</span><br><span class="line">gets(key);</span><br><span class="line">gets(mas);</span><br><span class="line">int i,j;//循环次数标识，i表示加密信息的下标，j表示key的下标 </span><br><span class="line">int lkey=strlen(key);</span><br><span class="line">int lmas=strlen(mas);//获取key和mas的长度，除去&#x27;\n&#x27; </span><br><span class="line">for(i=0,j=0;i&lt;lmas;i++,j++)&#123; </span><br><span class="line">if(j&gt;=lkey)&#123;//如果key下标超出最大值，将其初始化为0 </span><br><span class="line">j=0;</span><br><span class="line">&#125; </span><br><span class="line">if(65&gt;mas[i]mas[i]&gt;90)&#123;//如果加密信息不在A~Z之间就直接输出 </span><br><span class="line">printf(&quot;%c&quot;,mas[i]);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">char out=mas[i]+(key[j]-65);//新的加密后信息运算 </span><br><span class="line">if(out&gt;90)&#123;</span><br><span class="line">out-=26; </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%c&quot;,out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本题利用大写字母所对应的ASCII码字母和后移实际上就是ASCII码的后移，超过90的ASCII码就利用判断，将其减少26就在65到90之间了。如果ASCII码不在65~90之间就直接输出。</p>
<h1 id="4-字符串转换双精度浮点数"><a href="#4-字符串转换双精度浮点数" class="headerlink" title="4. 字符串转换双精度浮点数"></a>4. 字符串转换双精度浮点数</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>编写函数atof(s),把字符串s转化成相应的双精度浮点数.输入字符串可能含有如下几部分：正负号，整数部分，小数点，小数部分。该函数还能够处理形如123.45e-5的指数型字符串输入.输入字符串中不含有空格.编写一个程序,使用该函数,将输入的字符串转换成相应的双精度浮点数。</p>
<p>输入形式：控制台输入字符串s.它可以含有正负号,小数点,整数部分和小数部分,以及字符&amp;rsquo;e&amp;rsquo;和相应的指数部分。</p>
<p>输出形式：控制台输出转换后的双精度数.格式化输出,使用”%f”,即不需指定字段宽度,由系统自动指定,使整数部分全部如数输出，并保留6位小数部分。</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>根据题意，将字符串存入scr数组中，利用java中的Double.parseDouble()获得double类型数据，然后控制输出位数。</p>
<h2 id="代码（Java）"><a href="#代码（Java）" class="headerlink" title="代码（Java）"></a>代码（Java）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class atof &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner inp = new Scanner(System.in);</span><br><span class="line">String scr = inp.next();</span><br><span class="line">inp.close();</span><br><span class="line">double d = Double.parseDouble(scr);</span><br><span class="line">System.out.printf(&quot;%.6f&quot;,d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>该程序将字符串存入scr数组中，利用java中的Double.parseDouble()获得double类型数据d，然后利用System.out.printf(“%.6f”,d)控制输出位数。</p>
<h1 id="5-素数判断"><a href="#5-素数判断" class="headerlink" title="5. 素数判断"></a>5. 素数判断</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数isprime(n).判断整数n是否为素数.编写程序使用此函数,当输入一个整数时,对它进行判断,当为素数时,输出1.否则,输出0.</p>
<p>输入形式：控制台输入一个整数.</p>
<p>输出形式：控制台输出判断结果0或者1.</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>判断一个数字n是否为素数要用该数字依次除以从2到根号n，一旦有一个可以除尽的数字就不是素数。</p>
<h2 id="代码（c）-2"><a href="#代码（c）-2" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int isprime(int n)&#123;</span><br><span class="line">int i;</span><br><span class="line">int flag=1;</span><br><span class="line">for(i=2;i&lt;n;i++)&#123;</span><br><span class="line">if(n%i==0)&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">m=isprime(n);</span><br><span class="line">printf(&quot;%d&quot;,m);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本程序创建isprime()函数，其中参数为数字n，利用循环，将n除以2一直除到根号n，判断是否能除尽，有一个能除尽就返回0，否则返回1。</p>
<h1 id="6-消除游戏"><a href="#6-消除游戏" class="headerlink" title="6. 消除游戏"></a>6. 消除游戏</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。</p>
<p>现在给定一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子（用数字1-9表示各种颜色的棋子），请给出经过消除后的棋盘。</p>
<p>请注意：一个棋子可能在某一行和某一列同时被消除。</p>
<p>输入形式：从标准输入读取数据，第一行包含两个整数n和m，分别表示棋盘的行数和列数（行数和列数都大于等于3，小于等于9），以一个空格分隔这两个整数。</p>
<p>接下来输入n行，每行m个整数，用一个空格分隔各个整数，这些整数分别表示每一个方格中棋子的颜色（大于等于1，小于等于9）。</p>
<p>输出形式：向标准输出上输出n行，每行m个整数，相邻整数之间以一个空格分隔，表示经过消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出数字0，否则输出代表原棋子颜色的整数。每行最后一个整数后也要有一个空格。</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>根据题意创建二维数组存放原始数据。将原始数据复制到两个新的数组中，利用循环依次判断行与列该消除的数只需要按行遍历一次，再按列遍历一次，每次只需要判断三个数，就可以解决这个问题。将其变为0，最后合并这两个数组并输出。</p>
<h2 id="代码（Java）-1"><a href="#代码（Java）-1" class="headerlink" title="代码（Java）"></a>代码（Java）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class exam1 &#123;</span><br><span class="line">static void output(int[][] a, int n, int m) &#123;//输出函数output，参数：数据存放数组a，行n，列m</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">System.out.print(a[i][j]);</span><br><span class="line">if (j==m-1) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (i==n-1) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">int n = input.nextInt();</span><br><span class="line">int m = input.nextInt();</span><br><span class="line">int[][] a = new int[n][m];</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;//输入</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">a[i][j] = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">//output(a,n,m);</span><br><span class="line">int[][] row = new int[n][m];//行变换消除后的数据</span><br><span class="line">int[][] col = new int[n][m];//列变换消除后的数据</span><br><span class="line">int[][] fin = new int[n][m];//最终整合的数据</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">row[i][j] = a[i][j];</span><br><span class="line">col[i][j] = a[i][j];</span><br><span class="line">fin[i][j] = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//output(row,n,m);</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;//行变换消除数据</span><br><span class="line">for (int j = 0; j &lt; m-2; j++) &#123;</span><br><span class="line">if (a[i][j]==a[i][j+1]&amp;&amp;a[i][j]==a[i][j+2]) &#123;</span><br><span class="line">row[i][j] = 0;</span><br><span class="line">row[i][j+1] = 0;</span><br><span class="line">row[i][j+2] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//output(row,n,m);</span><br><span class="line">//System.out.println();</span><br><span class="line">//System.out.println();</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; n-2; j++) &#123;</span><br><span class="line">if (a[j][i]==a[j+1][i]&amp;&amp;a[j][i]==a[j+2][i]) &#123;</span><br><span class="line">col[j][i] = 0;</span><br><span class="line">col[j+1][i] = 0;</span><br><span class="line">col[j+2][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//output(col,n,m);</span><br><span class="line">//System.out.println();</span><br><span class="line">//System.out.println();</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">if (row[i][j]==0col[i][j]==0) &#123;</span><br><span class="line">fin[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output(fin, n, m);</span><br><span class="line">//System.out.println();</span><br><span class="line">//System.out.println();</span><br><span class="line">//output(a,n,m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本程序要保留下来原始数组，以免判断完行后列的数据不全导致判断错误。我都程序新建了一个output方法，将输出部分区块化方便在代码中间判断输出情况。</p>
<h1 id="7-合数分解2"><a href="#7-合数分解2" class="headerlink" title="7. 合数分解2"></a>7. 合数分解2</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>由数学基本定理可知：任何一个大于1的非素数整数（即合数）都可以唯一分解成若干个素数的乘积。编写程序，从控制台读入一个合数（合数的大小不会超过int数据类型表示的范围），求这个合数可以分解成的多次出现的素数（即出现次数大于1的素数）。例如合数1260分解成素数乘积为：2*2*3*3*5*7,2和3出现两次，5和7出现一次，所以求得的结果为2和3。</p>
<p>输入形式：从控制台输入一个合数。</p>
<p>输出形式：在标准输出上按照由小到大的顺序输出分解后的多次出现的素数，各素数之间以一个空格分隔，最后一个素数后也可以有一个空格。若没有多次出现的素数，则什么都不输出。</p>
<h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>根据题意，应该先判断输入数字num的所有质因子。然后循环将num依次除以从2到num的数字i，如果能整除，i不加1，同时再加入一个循环向其中添加一个参数，多次出现的质因子输出出来。</p>
<h2 id="代码（Java）-2"><a href="#代码（Java）-2" class="headerlink" title="代码（Java）"></a>代码（Java）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class primes &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">int num = input.nextInt();</span><br><span class="line">input.close();</span><br><span class="line">for (int i = 2; i &lt; num; i++) &#123;</span><br><span class="line">if (num%i==0) &#123;</span><br><span class="line">for (int j = 0; num%i==0; j++) &#123;</span><br><span class="line">num = num/i;</span><br><span class="line">if (j==1) &#123;</span><br><span class="line">System.out.print(i+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>该程序运用到了两层for循环嵌套，其中里面还有俩if判断，其中参数j在等于1的时候才会输出数字，其意义就是该质因子出现两次的时候会输出，同题目中的意思出现多次时输出一次该数字。</p>
<h1 id="8-摄氏华氏温度转换"><a href="#8-摄氏华氏温度转换" class="headerlink" title="8. 摄氏华氏温度转换"></a>8. 摄氏华氏温度转换</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>假如用C表示摄氏温度，F表示华氏温度，则有：F&#x3D;C*9&#x2F;5+32。输入一整数表示摄氏温度，根据该公式编程求对应的华氏温度，结果小数点后保留一位有效数字。</p>
<p>输入形式：从控制台读入一个整数，表示摄氏温度。</p>
<p>输出形式：向控制台输出转换后的华氏温度，结果小数点后保留一位有效数字。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>由题意，题目中给出了公式，利用scanf读取数字然后按照题目中的公式计算，然后输出数据即可。</p>
<h2 id="代码（c）-3"><a href="#代码（c）-3" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">double m,n;</span><br><span class="line">scanf(&quot;%lf&quot;,&amp;m);</span><br><span class="line">n=m*9/5+32;</span><br><span class="line">printf(&quot;%.1lf&quot;,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>本题程序中，输入的数据m也要变为double以免利用公式运算的时候出现小数部分没有计算入内的情况，输出的保留一位小数利用printf(“%.2lf”)即可完成题目要求。</p>
<h1 id="9-CCF-201612-1-中间数"><a href="#9-CCF-201612-1-中间数" class="headerlink" title="9. CCF 201612-1 中间数"></a>9. CCF 201612-1 中间数</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。给定一个整数序列，请找出这个整数序列的中间数的值。</p>
<p>输入形式：输入的第一行包含了一个整数n，表示整数序列中数的个数。第二行包含n个正整数，依次表示a1, a2, …, an。</p>
<p>输出形式：如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。</p>
<h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>由题意，由于输入的数据没有排序要求，本题采用暴力法，依次判断每个数字前比它小的数字，每个数字后比他大的数字的个数是否相等。</p>
<h2 id="代码（c）-4"><a href="#代码（c）-4" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">int a[n];</span><br><span class="line">int i,j,e,f;</span><br><span class="line">int flag=1;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">e=0;</span><br><span class="line">f=0;</span><br><span class="line">for(j=0;j&lt;n;j++)&#123;</span><br><span class="line">if(a[j]&lt;a[i])&#123;</span><br><span class="line">e++;</span><br><span class="line">&#125;</span><br><span class="line">else if(a[j]&gt;a[i])&#123;</span><br><span class="line">f++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(e==f&amp;&amp;e!=0)&#123;</span><br><span class="line">printf(&quot;%d&quot;,a[i]);</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">printf(&quot;-1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>本程序用暴力法依次计算前后大小的数字是否一致，利用flag来表示是否存在这样的数字，如果不存在这样的数字，根据flag等于0会输出-1。</p>
<h1 id="10-最小素数集"><a href="#10-最小素数集" class="headerlink" title="10. 最小素数集"></a>10. 最小素数集</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>由数学基本定理可知：任何一个大于1的非素数整数都可以唯一分解成若干个素数的乘积。编写程序，从控制台读入一组大于1的整数（小于等于20个，且每个整数的大小不会超过int数据类型表示的范围），求这些整数分解成素数的最小集。该最小素数集是所有整数分解成的素数的并集（若输入的整数是素数，则该素数可以直接加入最小素数集），并且重复的素数只保留一个。按从小到大的顺序输出求得的最小素数集。</p>
<p>输入形式：先从控制台输入整数的个数，然后在下一行输入所有整数，各整数之间以一个空格分隔。</p>
<p>输出形式：在标准输出上按从小到大顺序输出求得的最小素数集，各素数之间以一个空格分隔，最后一个整数后也可以有一个空格。</p>
<h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>根据题意先求出所有的数字的质因子，放在同一个数组里，然后从小到大依次排列，最后在依次输出，每个数字只输出一遍。</p>
<p>代码（Java）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class primes &#123;</span><br><span class="line">public static boolean judge(int x) &#123;//判断是否为素数，是素数返回true</span><br><span class="line">boolean flag = true;</span><br><span class="line">for(int i = 2; i &lt;= Math.sqrt((double)x); i++) &#123;</span><br><span class="line">if(x%i==0) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">public static int sti(String a) &#123;//string形转int型</span><br><span class="line">int result = 0;</span><br><span class="line">try &#123; </span><br><span class="line">    result = Integer.parseInt(a); </span><br><span class="line">&#125; catch (NumberFormatException e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">int n = input.nextInt();//输入数组个数</span><br><span class="line">int[] a = new int[n];//表示存放数字的数组</span><br><span class="line">ArrayList&lt;String&gt; midarray = new ArrayList&lt;String&gt;();</span><br><span class="line">for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">a[i] = input.nextInt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">for (int j = 2; j &lt;= a[i]; j++) &#123;</span><br><span class="line">if (judge(a[i])) &#123;</span><br><span class="line">midarray.add(&quot;&quot;+a[i]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if(a[i]%j==0) &#123;</span><br><span class="line">for (; a[i]%j==0; ) &#123;</span><br><span class="line">a[i] /= j;</span><br><span class="line">&#125;</span><br><span class="line">midarray.add(&quot;&quot;+j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">int w = 0;</span><br><span class="line">int l = midarray.size();</span><br><span class="line">int[] num = new int[l];</span><br><span class="line">for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">num[i] = sti(midarray.get(i));</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; l; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; l-1; j++) &#123;</span><br><span class="line">if(num[j]&gt;num[j+1]) &#123;</span><br><span class="line">int k = num[j];</span><br><span class="line">num[j] = num[j+1];</span><br><span class="line">num[j+1] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (l&gt;2) &#123;</span><br><span class="line">boolean flag = false;</span><br><span class="line">for (int i = 0; i &lt; l-1; i++) &#123;</span><br><span class="line">if (num[i]&lt;num[i+1]) &#123;</span><br><span class="line">w = i+1;</span><br><span class="line">System.out.print(num[i]);</span><br><span class="line">if (i==l-2) &#123;</span><br><span class="line">flag = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (num[l-1]&gt;num[l-2]) &#123;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">System.out.print(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(num[l-1]);</span><br><span class="line">&#125;</span><br><span class="line">else if (num[l-1]==num[w]) &#123;</span><br><span class="line">System.out.print(num[w]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (l==1) &#123;</span><br><span class="line">System.out.print(num[0]);</span><br><span class="line">&#125;</span><br><span class="line">else if (l==2) &#123;</span><br><span class="line">if (num[0]==num[1]) &#123;</span><br><span class="line">System.out.print(num[0]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">System.out.print(num[0]+&quot; &quot;+num[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>本程序中用judge方法来判断是否为素数，是素数返回true，用sti方法将string形数据转为int型数据。并在输出的时候建立一个标识w，让w称为最后一个数字的初始下标，以免少数出一个数字。</p>
<h1 id="11-求三角形面积"><a href="#11-求三角形面积" class="headerlink" title="11. 求三角形面积"></a>11. 求三角形面积</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式 求得三角形的面积，其中：s&#x3D;(a+b+c)&#x2F;2。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。</p>
<p>输入形式：从控制台输入三个整数表示三角形三个边的长度，以空格分隔三个整数。</p>
<p>输出形式：向控制台输出求得的三角形的面积，小数点后保留三位有效数字。</p>
<h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>由题意，题目中给出了公式，利用scanf读取数字然后按照题目中的公式计算，然后输出数据即可。</p>
<h2 id="代码（c）-5"><a href="#代码（c）-5" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">double a,b,c,p,s;</span><br><span class="line">scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">p=(a+b+c)/2;</span><br><span class="line">s=sqrt(p*(p-a)*(p-b)*(p-c));</span><br><span class="line">printf(&quot;%.3lf&quot;,s);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>本程序中用p表示半周长，然后根据公式计算得出面积的值，最后利用printf(“%.3lf”)输出保留了小数点后的三位数字。</p>
<h1 id="12-回文数"><a href="#12-回文数" class="headerlink" title="12. 回文数"></a>12. 回文数</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>“回文数”是一种数字。如：98789, 这个数字正读是98789,倒读也是98789,正读倒读一样，所以这个数字就是回文数。编写一个程序，判断给出的数m是否为回文数（m的位数&lt;&#x3D;1000）。</p>
<p>输入描述：一个整数m</p>
<p>输出描述：如果m是回文数，则输出yes，否则输出no（yes和no均为小写）</p>
<h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>根据题意，我将输入的数字视为字符串存入数组，然后判断数组实际长度，反过来存到另一个数组里，比较实际长度那么多的字符是否一致即可</p>
<p>代码（c）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[100],b[100];</span><br><span class="line">gets(a);</span><br><span class="line">int lentha=strlen(a);</span><br><span class="line">int i=lentha-1,j;</span><br><span class="line">for(j=0;i&gt;=0;i--)&#123;</span><br><span class="line">b[j]=a[i];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">int key=1;</span><br><span class="line">for(i=0;i&lt;lentha;i++)&#123;</span><br><span class="line">if(a[i]!=b[i])&#123;</span><br><span class="line">key=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(key)&#123;</span><br><span class="line">printf(&quot;yes&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>本题用到了get();来获取字符串。gets()用于从标准输入流stdin读入一个整行（以bai’\n’或EOF）结束，写入ptr指向的字符数组，并返回这个指针；出错或遇到文件结束时则返回NULL。行末的’\n’从流中取出，但不写入数组。gets()不检查被写入的数组大小。利用strlen()判断数组实际长度，然后反向写入另一个数组。依次判断两个数组中的每个数字是否一样，一旦出现一个不一样，将key标记为0。最后根据key输出yes或no。</p>
<h1 id="13-CCF-201703-4-地铁修建"><a href="#13-CCF-201703-4-地铁修建" class="headerlink" title="13. CCF 201703-4 地铁修建"></a>13. CCF 201703-4 地铁修建</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。</p>
<p>输入形式：输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。</p>
<p>输出形式：输出一个整数，修建整条地铁线路最少需要的天数。</p>
<h2 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h2><p>由题意本体就是最小生成树的题目。</p>
<p>代码（Java）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class subway &#123;</span><br><span class="line">static int[] fathers;</span><br><span class="line">static Comparator&lt;int[]&gt; cmp = new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">return o1[2] - o2[2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 优先队列方法</span><br><span class="line">// 85分，超时</span><br><span class="line">static void MST() &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">int num = scanner.nextInt();</span><br><span class="line">int route = scanner.nextInt();</span><br><span class="line">PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(cmp);</span><br><span class="line">// 初始化并查集</span><br><span class="line">fathers = new int[num + 1];</span><br><span class="line">for (int i = 1; i &lt;= num; i++) &#123;</span><br><span class="line">fathers[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">// 读取边</span><br><span class="line">for (int i = 0; i &lt; route; i++) &#123;</span><br><span class="line">int[] arr = new int[3];</span><br><span class="line">for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">arr[j] = scanner.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">queue.add(arr);</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"></span><br><span class="line">// Kruskal算法</span><br><span class="line">for (int i = 0; i &lt; route; i++) &#123;</span><br><span class="line">int[] edges = queue.poll();</span><br><span class="line">int a = edges[0], b = edges[1];</span><br><span class="line">int father_a = findfathers(a);</span><br><span class="line">int father_b = findfathers(b);</span><br><span class="line">if (father_a != father_b) &#123;</span><br><span class="line">fathers[father_a] = father_b;</span><br><span class="line">&#125;</span><br><span class="line">if (findfathers(1) == findfathers(num)) &#123;</span><br><span class="line">System.out.println(edges[2]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int findfathers(int child) &#123;</span><br><span class="line">int father = child;</span><br><span class="line">while (fathers[father] != father) &#123;</span><br><span class="line">father = fathers[father];</span><br><span class="line">&#125;</span><br><span class="line">// 路径压缩</span><br><span class="line">int i = child, j;</span><br><span class="line">while (i != father) &#123;</span><br><span class="line">j = fathers[i];</span><br><span class="line">fathers[i] = father;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">return father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MST();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p>利用最小生成树算法。最小生成树性质：设G&#x3D;(V，E）是一个连通网络，U是顶点集V的一个非空真子集。若(u，v）是G中一条“一个端点在U中（例如：u∈U），另一个端点不在U中的边（例如：v∈V-U），且（u，v）具有最小权值，则一定存在G的一棵最小生成树包括此边（u，v）。</p>
<h1 id="14-CCF-201512-1-数位之和"><a href="#14-CCF-201512-1-数位之和" class="headerlink" title="14. CCF 201512-1 数位之和"></a>14. CCF 201512-1 数位之和</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>给定一个十进制整数n，输出n的各位数字之和。</p>
<p>输入形式：输入一个整数n。</p>
<p>输出形式：输出一个整数，表示答案。</p>
<h2 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h2><p>根据题意将数字看成字符串然后根据每个字符串改为数字，最后将所有的数字加在一起能得出答案。</p>
<h2 id="代码（c）-6"><a href="#代码（c）-6" class="headerlink" title="代码（c）"></a>代码（c）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define chartonumber(x) (x-&#x27;0&#x27;)</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[10];</span><br><span class="line">fgets(a, 10, stdin);</span><br><span class="line">int sum=0;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;strlen(a)-1;i++)&#123;</span><br><span class="line">sum+=chartonumber(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;,sum);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>本程序用fgets()获取字符，fgets函数功能为从指定的流中读取数据，每次读取一行。其原型为：char *fgets(char *str, int n, FILE *stream);从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。利用宏定义#define chartonumber(x) (x-‘0’)将char类型数据转换为int类型数据。</p>
<h1 id="15-逆序乘积式"><a href="#15-逆序乘积式" class="headerlink" title="15. 逆序乘积式"></a>15. 逆序乘积式</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>若两个正整数的乘积，等于两正整数各自逆序后的乘积，则称其为逆序乘积式。编写程序读入两个正整数，然后判断这两个正整数能否构成逆序乘积式。假设两个正整数的乘积不会超过int数据类型的表示范围。</p>
<p>输入形式：从控制台输入以一个空格分隔的两个正整数。</p>
<p>输出形式：若两个正整数能够构成逆序乘积式，则输出两个正整数及其逆序的乘积形式，并且中间用一个等号相连；若不能构成逆序乘积式，则输出两个正整数及其逆序的乘积形式，并且中间用一个不等号相连。</p>
<p>注意：输出的字符之间没有空格分隔。若逆序后最高位为0，则为0的最高位不输出。</p>
<h2 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h2><p>根据题意，本程序结合了将数字反过来读取，和判断乘积是否相等。</p>
<h2 id="代码（Java）-3"><a href="#代码（Java）-3" class="headerlink" title="代码（Java）"></a>代码（Java）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class exam &#123;</span><br><span class="line">static int changetonumber(String y) &#123;</span><br><span class="line">int result = 0;</span><br><span class="line">try &#123; </span><br><span class="line">    result = Integer.parseInt(y); </span><br><span class="line">&#125; catch (NumberFormatException e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">boolean flag = true;</span><br><span class="line">Scanner input = new Scanner(System.in);</span><br><span class="line">StringBuilder a = new StringBuilder(input.next());</span><br><span class="line">StringBuilder b = new StringBuilder(input.next());</span><br><span class="line">String sa = &quot;&quot;+a;</span><br><span class="line">String sb = &quot;&quot;+b;</span><br><span class="line">StringBuilder backa = a;</span><br><span class="line">StringBuilder backb = b;</span><br><span class="line">backa.reverse();</span><br><span class="line">backb.reverse();</span><br><span class="line">String sbacka = &quot;&quot;+backa;</span><br><span class="line">String sbackb = &quot;&quot;+backb;</span><br><span class="line">int numa = changetonumber(sa);</span><br><span class="line">int numb = changetonumber(sb);</span><br><span class="line">int numba = changetonumber(sbacka);</span><br><span class="line">int numbb = changetonumber(sbackb);</span><br><span class="line">if (numa*numb==numba*numbb) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">System.out.print(numa+&quot;*&quot;+numb);</span><br><span class="line">if (flag) &#123;</span><br><span class="line">System.out.print(&quot;!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;=&quot;+numba+&quot;*&quot;+numbb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><p>本程序利用一个changetonumber方法将字符串转换为数字返回，先读取字符串，然后将字符串复制到另一个StringBuilder类型数据里，将其反向，然后利用新建的方法将其转换为数字，最后判断输出结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/6/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">转接</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">Kategorien</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">转接</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
