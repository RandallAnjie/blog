---
title: 第5章 传输层
tags: []
id: '824'
categories:
  - - 研
comments: false
---

# 第五章 传输层

#计算机网络

只有主机才有的层次

## 传输层提供的服务

### 传输层的功能：

1.  提供进程和进程之间的逻辑通信（端到端通信）
2.  复用和分用
    *   复用：发送方不同的应用进程都可使用同一个传输层协议传送数据
    *   分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程
3.  传输层对收到的报文进行差错检测（首部和数据部分）
4.  提供两种不同的传输协议
    *   TCP：面向连接，传送单元为报文段，==可靠，面向连接，时延大，适用于大文件==
        *   传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等
        *   面向连接的服务可以保证数据的可靠和顺序交付
    *   UDP：无连接，传送单元为用户数据报，==不可靠，无连接，时延小，适用于小文件==
        *   传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认

\==**如果一个协议使用确认机制对传输数据进行确认，则认为它是一个可靠的协议**\==

### 传输层的寻址与端口

复用：应用层所有的应用进程都可以通过传输层再传输到网络层。 分用：传输层从网络层收到数据后交付指明的应用进程

端口：这里的端口是逻辑端口（又称软件端口），是传输层的\[\[第1章 计算机网络体系结构#^690d1aSAP\]\]，标识主机中的应用进程 端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的 端口号长度为16bit，能表示65536个不同的端口号

```tree
└─按照范围划分端口
   ├─服务端使用的端口号
    ├─熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户知道（0~1023）
    └─登记端口号：为没有熟知端口号的应用程序使用（1024~49151）
   └─客户端使用的端口号：仅在客户进程运行时才动态选择（49152~65535）（操作系统分配）
```

一些常用的熟知端口号：

应用程序

FTP

TELNET

SMTP

DNS

TFTP

HTTP

SNMP

熟知端口号

21

23

25

53

69

80

161

!\[\[熟知端口号.png\]\]

### 套接字

在网络中采用发送方和接收方的套接字组合来识别端点，**套接字**唯一标识了网络中的一个主机和它上面的一个进程 套接字 Socket=（主机IP地址：端口号）

## UDP协议

\[\[第5章 传输层#^80407dUDP是面向报文的\]\]

### UDP数据报

UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能

#### UDP特点：

1.  UDP是**无连接**的，减少开销和发送数据之前的时延
2.  UDP使用最大努力交付，即**不保证可靠交付**
    *   可靠交付交给应用层实现
3.  UDP是**面向报文**的，适合一次性传输少量数据的网络应用 ^80407d
    *   面向报文：应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文 ，不拆分应用层传下来的报文
4.  UDP**无拥塞控制**，适合很多实时应用
5.  UDP首部开销小，占8B（TCP首部占20B）

#### UDP首部格式

!\[\[UDP首部格式.png\]\]

*   首部字段（8B）：
    *   源端口：在需要对方回信时选用。不需要可用全0
    *   目的端口：在终点交付时需要用到
    *   长度：UDP数据报长度（包括首部和数据），最小值为8
    *   校验和：检测udp数据报是否有错
*   数据字段：如果没有可为空

分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送IMP“端口不可达”差错报告报文

### UDP校验

> UDP的校验和不是必须的，如果不使用校验和，那么将校验和字段设置为0，如果校验和的计算结果恰好为0，那么将校验和字段置为全1

UDP数据报： !\[\[UDP数据报.png\]\]

*   伪首部只有在计算检验和时才出现，不向下传送也不向上递交
*   17:封装UDP报文的IP数据报首部协议字段是17
*   UDP长度：UDP首部8B+数据部分长度（不包括伪首部）

UDP校验计算： !\[\[UDP校验计算.png\]\]

**在发送端**：

1.  填上伪首部
2.  全0填充检验和字段
3.  全0填充数据部分（UDP数据报要看成许多4B的字串接起来）
4.  伪首部+首部+数据部分采用二进制反码求和
5.  把==和求**反码**\==填入检验和字段
6.  去掉伪首部，发送

**在接收端**：

1.  填上伪首部
2.  伪首部+首部+数据部分采用二进制反码求和
3.  结果==**全为1则无差错**\==，否则丢弃数据报/交给应用层附上出差错的警告

## TCP协议

\[\[第5章 传输层#^e13772TCP是面向字节流\]\]

### TCP协议的特点

1.  TCP是面向连接（虚连接）的传输层协议
2.  每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
3.  TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达==（可靠有序，不丢不重）==
4.  TCP提供全双工通信
    *   发送缓存准备发送的数据&已发送但尚未收到确认的数据
    *   接收缓存按序到达但尚未被接受应用程序读取的数据&不按序到达的数据
5.  TCP面向字节流，TCP把应用程序交下来的数据看成仅仅是一连串的==无结构的字节流== ^e13772
    *   流：流入到进程或从进程流出的字节序列

### TCP报文

!\[\[TCP报文.png\]\]

*   序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的**第一个字节的序号** ^1eb565
*   确认号：**期望**收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到
*   数据偏移（==**首部长度**\==）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以==4B位单位==，即1个数值是4B
*   6个控制位：
    *   \==URG紧急位==：URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送（在发送缓存里插队），不用在缓存里排队，配合紧急指针字段使用
    *   \==ACK确认位==：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1
    *   PSH推送位：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付
    *   RST复位：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接，也可用来拒绝一个非法报文段或拒绝打开一个连接
    *   \==SYN同步位==：SYN=1时，表明是一个连接请求/连接接受报文
    *   \==FIN终止位==：FIN=1时，表明此报文段发送方数据已发完，要求释放连接
*   窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量，单位字节 ^f8f907
*   检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6
*   紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数
    *   紧急数据在数据报数据部最前面，即前多少位为紧急数据
*   选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认…
    *   MSS是TCP报文段中==数据字段==的最大长度

### TCP连接管理

TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器

#### TCP的连接建立

!\[\[TCP的连接建立.png\]\]

1.  客户端发送连接请求报文段，无应用层数据
    *   SYN=1，seq=x(随机)
2.  服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据
    *   SYN=1，ACK=1，seq=y(随机)，ack=x+1
    *   ACK为1同时要有ack（下个期望收到的序列）的值
3.  客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据
    *   SYN=0，ACK=1，seq=x+1，ack=y+1

> SYN洪泛攻击：SYN是TCP三次握手中的第一个数据包，客户机一直发送第一次握手，而不对服务器的确认进行确认，导致大量TCP连接被挂起 解决方案：SYN cookie

#### TCP的连接释放

!\[\[TCP的连接释放.png\]\]

1.  客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接
    *   FIN=1，seq=u
2.  服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了一一半关闭状态
    *   ACK=1，seq=v，ack=u+1
3.  服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接
    *   FIN=1，ACK=1，seg=w，ack=u+1
4.  客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL(最长报文段寿命)后，连接彻底关闭
    *   ACK=1，seq=u+1，ack=W+1

#### TCP的可靠传输

可靠传输：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的

TCP实现可靠传输的机制：

1.  校验：
    *   与UDP一样增加伪（IP）首部（17代表UDP，6代表TCP），计算校验和
2.  序号：
    *   一个字节占一个序号
    *   \[\[第5章 传输层#^1eb565序号字段\]\]指的是一个报文段第一个字节的序号
3.  确认：
    *   TCP默认使用累计确认
4.  重传：
    1.  超时重传
        *   确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段
        *   重传时间：TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)
    2.  冗余ACK（冗余确认）
        *   每当比期望序号大的失序报文段到达时，发送一个冗余AK,指明下一个期待字节的序号
        *   当发送方收到对同一个报文段的==**3个冗余ACK**\==时，就可以认为跟在这个被确认报文段之后的报文段已丢失（快速重传）

#### TCP的流量控制

为了让接收方来得及接收数据，让发送方发慢一点

TCP利用**滑动窗口**机制实现流量控制

在通信过程中，接收方根据自己**接收缓存的大小**，动态地调整发送方的发送窗口大小，即\[\[第5章 传输层#^rwrdcwrd接收窗口rwnd\]\]（接收方设置确认报文段的**窗口字段**来将rwnd通知给发送方），发送方的**发送窗口**取\[\[第5章 传输层#^rwrdcwrd接收窗口rwnd和拥塞窗口cwnd\]\]的最小值（==发送方的发送窗口=min{接收窗口rwnd，拥塞窗口cwnd}==）（发送窗口可以动态变化）

接收窗口rwrd可由接收方的确认报文传回

rwrd设置为0时：禁止发送方发送数据

*   TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器
*   若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接收方收到探测报文段时给出现在的窗口值
*   若窗口仍然是0，那么发送方就重新设置持续计时器

#### TCP的拥塞控制

出现拥塞的条件：

*   对资源需求的总和>可用资源
*   网络中有许多资源同时呈现供应不足=>网络性能变坏=>网络吞吐量将随输入负荷增大而下降

##### 拥塞控制四种方法

1.  慢开始
2.  拥塞避免
3.  快重传
4.  快恢复

\==**假定：**\==

1.  数据单方向传送，而另一个方向只传送确认
2.  接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度

发送窗口=min{接收窗口rwnd，拥塞窗口cwnd}

接收窗口rwrd：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量 拥塞窗口cwrd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量 ^rwrdcwrd

> \[\[第5章 传输层#^f8f907窗口单位为字节\]\]，发送窗口为1000即为收到确认前最多发1000B数据

慢开始和拥塞避免： !\[\[慢开始和拥塞避免.png\]\]

一个传输轮次：

*   发送了一批报文段并收到它们的确认的时间
*   一个往返时延RTT
*   开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间

ssthresh：满开始门限

快重传和快恢复： !\[\[快重传和快恢复.png\]\]

##### 流量控制和拥塞控制的区别

*   流量控制：
    *   点到点控制
    *   发送方的速率过快导致这个接收方它接收缓存不够或者说它的接收窗口不够
*   拥塞控制：
    *   全局性问题
    *   因为这个网络发生了堵塞导致很多发送方发送来的数据到不了接收方